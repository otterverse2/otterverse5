const e=Symbol(),t=Symbol(),r=Symbol(),n=Object.getPrototypeOf,o=new WeakMap,s=e=>e&&(o.has(e)?o.get(e):n(e)===Object.prototype||n(e)===Array.prototype),c=e=>"object"==typeof e&&null!==e,i=(n,o)=>{let s=!1;const c=(t,r,o)=>{if(!s){let s=t.a.get(n);s||(s=new Set,t.a.set(n,s)),o&&s.has(e)||s.add(r)}},i={f:o,get(e,t){return t===r?n:(c(this,t),l(e[t],this.a,this.c))},has(e,r){return r===t?(s=!0,this.a.delete(n),!0):(c(this,r),r in e)},getOwnPropertyDescriptor(e,t){return c(this,t,!0),Object.getOwnPropertyDescriptor(e,t)},ownKeys(t){return c(this,e),Reflect.ownKeys(t)}};return o&&(i.set=i.deleteProperty=()=>!1),i},a=e=>e[r]||e,l=(e,t,r)=>{if(!s(e))return e;const o=a(e),c=(e=>Object.isFrozen(e)||Object.values(Object.getOwnPropertyDescriptors(e)).some(e=>!e.writable))(o);let l=r&&r.get(o);return l&&l.f===c||(l=i(o,c),l.p=new Proxy(c?(e=>{if(Array.isArray(e))return Array.from(e);const t=Object.getOwnPropertyDescriptors(e);return Object.values(t).forEach(e=>{e.configurable=!0}),Object.create(n(e),t)})(o):o,l),r&&r.set(o,l)),l.a=t,l.c=r,l.p},u=(e,t)=>{const r=Reflect.ownKeys(e),n=Reflect.ownKeys(t);return r.length!==n.length||r.some((e,t)=>e!==n[t])},f=(t,r,n,o)=>{if(Object.is(t,r))return!1;if(!c(t)||!c(r))return!0;const s=n.get(a(t));if(!s)return!0;if(o){const e=o.get(t);if(e&&e.n===r)return e.g;o.set(t,{n:r,g:!1})}let i=null;for(const c of s){const s=c===e?u(t,r):f(t[c],r[c],n,o);if(!0!==s&&!1!==s||(i=s),i)break}return null===i&&(i=!0),o&&o.set(t,{n:r,g:i}),i},y=e=>!!s(e)&&t in e,p=e=>s(e)&&e[r]||null,g=(e,t=!0)=>{o.set(e,t)},b=(e,t)=>{const r=[],n=new WeakSet,o=(e,s)=>{if(n.has(e))return;c(e)&&n.add(e);const i=c(e)&&t.get(a(e));i?i.forEach(t=>{o(e[t],s?[...s,t]:[t])}):s&&r.push(s)};return o(e),r};export{b as affectedToPathList,l as createProxy,p as getUntracked,f as isChanged,g as markToTrack,y as trackMemo};
//# sourceMappingURL=index.modern.js.map
