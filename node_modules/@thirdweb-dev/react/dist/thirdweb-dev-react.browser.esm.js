import { ChainId, getProviderForNetwork, ThirdwebSDK, CONTRACTS_MAP, SmartContract, Erc1155, Erc721, ListingType, UserWallet } from '@thirdweb-dev/sdk/dist/browser';
export { ChainId, IpfsStorage } from '@thirdweb-dev/sdk/dist/browser';
import { utils, ethers, providers, Signer, constants, BigNumber } from 'ethers';
import invariant from 'tiny-invariant';
import { normalizeChainId, Connector, useSigner as useSigner$1, useAccount, useNetwork as useNetwork$1, WagmiProvider, useProvider, useConnect as useConnect$1 } from 'wagmi';
export { defaultChains, defaultL2Chains, useAccount, useProvider } from 'wagmi';
import { NATIVE_TOKENS, SUPPORTED_CHAIN_IDS, ChainId as ChainId$1 } from '@thirdweb-dev/sdk';
import React, { useMemo, useContext, createContext, useRef, useEffect, useState, useCallback, useId } from 'react';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { QueryClient, QueryClientProvider, useQueryClient, useQuery, useMutation } from '@tanstack/react-query';
import { CoinbaseWalletConnector } from 'wagmi/connectors/coinbaseWallet';
import { InjectedConnector } from 'wagmi/connectors/injected';
import { WalletConnectConnector } from 'wagmi/connectors/walletConnect';
import { detect } from 'detect-browser';
import mime from 'mime/lite.js';
import useDimensions from 'react-cool-dimensions';
import copy from 'copy-to-clipboard';
import styled from '@emotion/styled';
import { keyframes, ThemeProvider as ThemeProvider$1 } from '@emotion/react';
import color from 'color';
import { Portal } from '@reach/portal';
import * as menu from '@zag-js/menu';
import { useMachine, normalizeProps } from '@zag-js/react';
import { FiChevronDown, FiCheck, FiCopy, FiWifi, FiXCircle } from 'react-icons/fi';

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _regeneratorRuntime() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  _regeneratorRuntime = function () {
    return exports;
  };

  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");

        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);

          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if ("throw" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) keys.push(key);

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

var _CHAIN_ID_TO_GNOSIS_S;
var CHAIN_ID_TO_GNOSIS_SERVER_URL = (_CHAIN_ID_TO_GNOSIS_S = {}, _defineProperty(_CHAIN_ID_TO_GNOSIS_S, ChainId.Mainnet, "https://safe-transaction.mainnet.gnosis.io"), _defineProperty(_CHAIN_ID_TO_GNOSIS_S, ChainId.Avalanche, "https://safe-transaction.avalanche.gnosis.io"), _defineProperty(_CHAIN_ID_TO_GNOSIS_S, ChainId.Polygon, "https://safe-transaction.polygon.gnosis.io"), _defineProperty(_CHAIN_ID_TO_GNOSIS_S, ChainId.Goerli, "https://safe-transaction.goerli.gnosis.io"), _defineProperty(_CHAIN_ID_TO_GNOSIS_S, ChainId.Rinkeby, "https://safe-transaction.rinkeby.gnosis.io"), _CHAIN_ID_TO_GNOSIS_S);

var __IS_SERVER__$1 = "object" === "undefined";

var GnosisSafeConnector = /*#__PURE__*/function (_Connector) {
  _inherits(GnosisSafeConnector, _Connector);

  var _super = _createSuper(GnosisSafeConnector);

  // config
  function GnosisSafeConnector(config) {
    var _config$chains;

    var _this;

    _classCallCheck(this, GnosisSafeConnector);

    // filter out any chains that gnosis doesnt support before passing to connector
    config.chains = (_config$chains = config.chains) === null || _config$chains === void 0 ? void 0 : _config$chains.filter(function (c) {
      return c.id in CHAIN_ID_TO_GNOSIS_SERVER_URL;
    });
    _this = _super.call(this, _objectSpread2(_objectSpread2({}, config), {}, {
      options: undefined
    }));

    _defineProperty(_assertThisInitialized(_this), "id", "gnosis");

    _defineProperty(_assertThisInitialized(_this), "ready", __IS_SERVER__$1);

    _defineProperty(_assertThisInitialized(_this), "name", "Gnosis Safe");

    _defineProperty(_assertThisInitialized(_this), "previousConnector", void 0);

    _defineProperty(_assertThisInitialized(_this), "config", void 0);

    _defineProperty(_assertThisInitialized(_this), "safeSigner", void 0);

    {
      _this.ready = true;
    }

    return _this;
  }

  _createClass(GnosisSafeConnector, [{
    key: "connect",
    value: function () {
      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var account, provider, id;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.createSafeSigner();

              case 2:
                this.safeSigner = _context.sent;
                _context.next = 5;
                return this.getAccount();

              case 5:
                account = _context.sent;
                _context.next = 8;
                return this.getProvider();

              case 8:
                provider = _context.sent;
                _context.next = 11;
                return this.getChainId();

              case 11:
                id = _context.sent;
                return _context.abrupt("return", {
                  account: account,
                  provider: provider,
                  chain: {
                    id: id,
                    unsupported: this.isChainUnsupported(id)
                  }
                });

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function connect() {
        return _connect.apply(this, arguments);
      }

      return connect;
    }()
  }, {
    key: "createSafeSigner",
    value: function () {
      var _createSafeSigner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var _this$previousConnect, _this$config, _this$config2;

        var signer, safeAddress, safeChainId, signerChainId, serverUrl, _yield$Promise$all, _yield$Promise$all2, safeEthersAdapters, safeCoreSdk, safeEthersLib, ethAdapter, safe, service;

        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return (_this$previousConnect = this.previousConnector) === null || _this$previousConnect === void 0 ? void 0 : _this$previousConnect.getSigner();

              case 2:
                signer = _context2.sent;
                safeAddress = (_this$config = this.config) === null || _this$config === void 0 ? void 0 : _this$config.safeAddress;
                safeChainId = (_this$config2 = this.config) === null || _this$config2 === void 0 ? void 0 : _this$config2.safeChainId;
                invariant(signer, "cannot create Gnosis Safe signer without a personal signer");
                _context2.next = 8;
                return signer.getChainId();

              case 8:
                signerChainId = _context2.sent;
                invariant(signerChainId === safeChainId, "chainId of personal signer has to match safe chainId");
                invariant(safeAddress, "safeConfig.safeAddress is required, did you forget to call setSafeConfig?");
                invariant(safeChainId, "safeConfig.safeChainId is required, did you forget to call setSafeConfig?");
                serverUrl = CHAIN_ID_TO_GNOSIS_SERVER_URL[safeChainId];
                invariant(serverUrl, "Chain not supported");
                _context2.next = 16;
                return Promise.all([import('@gnosis.pm/safe-ethers-adapters'), import('@gnosis.pm/safe-core-sdk'), import('@gnosis.pm/safe-ethers-lib')]);

              case 16:
                _yield$Promise$all = _context2.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 3);
                safeEthersAdapters = _yield$Promise$all2[0];
                safeCoreSdk = _yield$Promise$all2[1];
                safeEthersLib = _yield$Promise$all2[2];
                ethAdapter = new safeEthersLib["default"]({
                  ethers: ethers,
                  signer: signer
                });
                _context2.next = 24;
                return safeCoreSdk["default"].create({
                  ethAdapter: ethAdapter,
                  safeAddress: safeAddress
                });

              case 24:
                safe = _context2.sent;
                service = new safeEthersAdapters.SafeService(serverUrl);
                return _context2.abrupt("return", new safeEthersAdapters.SafeEthersSigner(safe, service, signer.provider));

              case 27:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function createSafeSigner() {
        return _createSafeSigner.apply(this, arguments);
      }

      return createSafeSigner;
    }()
  }, {
    key: "disconnect",
    value: function () {
      var _disconnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this.config = undefined;
                this.safeSigner = undefined;
                this.previousConnector = undefined;
                return _context3.abrupt("return", undefined);

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function disconnect() {
        return _disconnect.apply(this, arguments);
      }

      return disconnect;
    }()
  }, {
    key: "getAccount",
    value: function () {
      var _getAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        var signer;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getSigner();

              case 2:
                signer = _context4.sent;
                _context4.next = 5;
                return signer.getAddress();

              case 5:
                return _context4.abrupt("return", _context4.sent);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getAccount() {
        return _getAccount.apply(this, arguments);
      }

      return getAccount;
    }()
  }, {
    key: "getChainId",
    value: function () {
      var _getChainId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.getSigner();

              case 2:
                return _context5.abrupt("return", _context5.sent.getChainId());

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getChainId() {
        return _getChainId.apply(this, arguments);
      }

      return getChainId;
    }()
  }, {
    key: "getProvider",
    value: function () {
      var _getProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getSigner();

              case 2:
                return _context6.abrupt("return", _context6.sent.provider);

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getProvider() {
        return _getProvider.apply(this, arguments);
      }

      return getProvider;
    }()
  }, {
    key: "getSigner",
    value: function () {
      var _getSigner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (this.safeSigner) {
                  _context7.next = 4;
                  break;
                }

                _context7.next = 3;
                return this.createSafeSigner();

              case 3:
                this.safeSigner = _context7.sent;

              case 4:
                return _context7.abrupt("return", this.safeSigner);

              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getSigner() {
        return _getSigner.apply(this, arguments);
      }

      return getSigner;
    }()
  }, {
    key: "isAuthorized",
    value: function () {
      var _isAuthorized = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        var account;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.prev = 0;
                _context8.next = 3;
                return this.getAccount();

              case 3:
                account = _context8.sent;
                return _context8.abrupt("return", !!account);

              case 7:
                _context8.prev = 7;
                _context8.t0 = _context8["catch"](0);
                return _context8.abrupt("return", false);

              case 10:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[0, 7]]);
      }));

      function isAuthorized() {
        return _isAuthorized.apply(this, arguments);
      }

      return isAuthorized;
    }()
  }, {
    key: "onAccountsChanged",
    value: function onAccountsChanged(accounts) {
      if (accounts.length === 0) {
        this.emit("disconnect");
      } else {
        this.emit("change", {
          account: utils.getAddress(accounts[0])
        });
      }
    }
  }, {
    key: "isChainUnsupported",
    value: function isChainUnsupported(chainId) {
      var _this$config3;

      return (_this$config3 = this.config) !== null && _this$config3 !== void 0 && _this$config3.safeChainId ? chainId === this.config.safeChainId : false;
    }
  }, {
    key: "onChainChanged",
    value: function onChainChanged(chainId) {
      var id = normalizeChainId(chainId);
      var unsupported = this.isChainUnsupported(id);
      this.emit("change", {
        chain: {
          id: id,
          unsupported: unsupported
        }
      });
    }
  }, {
    key: "onDisconnect",
    value: function onDisconnect() {
      this.emit("disconnect");
    }
  }, {
    key: "setConfiguration",
    value: function setConfiguration(connector, config) {
      this.previousConnector = connector;
      this.config = config;
    }
  }]);

  return GnosisSafeConnector;
}(Connector);

var _excluded$9 = ["apiKey", "doNotAutoConnect", "rpcUrls"];

var __IS_SERVER__ = "object" === "undefined";

var LOCAL_STORAGE_KEY = "--magic-link:configuration";
var MagicConnector = /*#__PURE__*/function (_Connector) {
  _inherits(MagicConnector, _Connector);

  var _super = _createSuper(MagicConnector);

  function MagicConnector(config) {
    var _this;

    _classCallCheck(this, MagicConnector);

    _this = _super.call(this, _objectSpread2(_objectSpread2({}, config), {}, {
      options: config === null || config === void 0 ? void 0 : config.options
    }));

    _defineProperty(_assertThisInitialized(_this), "id", "magic");

    _defineProperty(_assertThisInitialized(_this), "name", "Magic");

    _defineProperty(_assertThisInitialized(_this), "ready", __IS_SERVER__);

    _defineProperty(_assertThisInitialized(_this), "options", void 0);

    _defineProperty(_assertThisInitialized(_this), "configuration", void 0);

    _defineProperty(_assertThisInitialized(_this), "magic", void 0);

    _this.options = config.options;

    {
      _this.ready = true;

      if (_this.options.doNotAutoConnect || !_this.getConfiguration()) {
        return _possibleConstructorReturn(_this);
      }

      _this.connect(true);
    }

    return _this;
  }

  _createClass(MagicConnector, [{
    key: "getConfiguration",
    value: function getConfiguration() {

      var config = window.localStorage.getItem(LOCAL_STORAGE_KEY);

      if (config) {
        this.configuration = JSON.parse(config);
      }

      return this.configuration;
    }
  }, {
    key: "connect",
    value: function () {
      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(isAutoConnect) {
        var _this2 = this;

        var _this$options, apiKey, options, configuration;

        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _this$options = this.options, apiKey = _this$options.apiKey, _this$options.doNotAutoConnect, _this$options.rpcUrls, options = _objectWithoutProperties(_this$options, _excluded$9);
                configuration = this.getConfiguration();
                _context2.prev = 2;
                invariant(configuration, "did you forget to set the configuration via: setConfiguration()?");

                if (isAutoConnect) {
                  configuration.showUI = false;
                }

                return _context2.abrupt("return", import('magic-sdk').then( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(m) {
                    var provider, account, id;
                    return _regeneratorRuntime().wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            _this2.magic = new m.Magic(apiKey, options);
                            _context.next = 3;
                            return _this2.magic.auth.loginWithMagicLink(configuration);

                          case 3:
                            provider = _this2.getProvider();

                            if (provider.on) {
                              provider.on("accountsChanged", _this2.onAccountsChanged);
                              provider.on("chainChanged", _this2.onChainChanged);
                              provider.on("disconnect", _this2.onDisconnect);
                            }

                            _context.next = 7;
                            return _this2.getAccount();

                          case 7:
                            account = _context.sent;
                            _context.next = 10;
                            return _this2.getChainId();

                          case 10:
                            id = _context.sent;
                            return _context.abrupt("return", {
                              account: account,
                              provider: provider,
                              chain: {
                                id: id,
                                unsupported: _this2.isChainUnsupported(id)
                              }
                            });

                          case 12:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function (_x2) {
                    return _ref.apply(this, arguments);
                  };
                }()));

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](2);

                if (isAutoConnect) {
                  _context2.next = 12;
                  break;
                }

                throw _context2.t0;

              case 12:
                return _context2.abrupt("return", {
                  account: undefined,
                  provider: undefined,
                  chain: undefined
                });

              case 13:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[2, 8]]);
      }));

      function connect(_x) {
        return _connect.apply(this, arguments);
      }

      return connect;
    }()
  }, {
    key: "disconnect",
    value: function () {
      var _disconnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var provider;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                provider = this.getProvider();

                if (provider !== null && provider !== void 0 && provider.removeListener) {
                  provider.removeListener("accountsChanged", this.onAccountsChanged);
                  provider.removeListener("chainChanged", this.onChainChanged);
                  provider.removeListener("disconnect", this.onDisconnect);
                }

                this.setConfiguration(undefined);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function disconnect() {
        return _disconnect.apply(this, arguments);
      }

      return disconnect;
    }()
  }, {
    key: "switchChain",
    value: function () {
      var _switchChain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(chainId) {
        var provider;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                invariant(!this.isChainUnsupported(chainId), "chain is not supported");
                provider = this.getProvider();

                if (provider !== null && provider !== void 0 && provider.removeListener) {
                  provider.removeListener("accountsChanged", this.onAccountsChanged);
                  provider.removeListener("chainChanged", this.onChainChanged);
                  provider.removeListener("disconnect", this.onDisconnect);
                }

                this.options.network = {
                  chainId: chainId,
                  rpcUrl: this.options.rpcUrls[chainId]
                };
                _context4.next = 6;
                return this.connect();

              case 6:
                this.onChainChanged(chainId);
                return _context4.abrupt("return", this.chains.find(function (c) {
                  return c.id === chainId;
                }));

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function switchChain(_x3) {
        return _switchChain.apply(this, arguments);
      }

      return switchChain;
    }()
  }, {
    key: "getAccount",
    value: function () {
      var _getAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var signer;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.getSigner();

              case 2:
                signer = _context5.sent;
                _context5.next = 5;
                return signer.getAddress();

              case 5:
                return _context5.abrupt("return", _context5.sent);

              case 6:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getAccount() {
        return _getAccount.apply(this, arguments);
      }

      return getAccount;
    }()
  }, {
    key: "getChainId",
    value: function () {
      var _getChainId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        var signer;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getSigner();

              case 2:
                signer = _context6.sent;
                _context6.next = 5;
                return signer.getChainId();

              case 5:
                return _context6.abrupt("return", _context6.sent);

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getChainId() {
        return _getChainId.apply(this, arguments);
      }

      return getChainId;
    }()
  }, {
    key: "getProvider",
    value: function getProvider() {
      invariant(this.magic, "connector is not initialized");
      return new providers.Web3Provider(this.magic.rpcProvider);
    }
  }, {
    key: "getSigner",
    value: function () {
      var _getSigner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (this.magic) {
                  _context7.next = 3;
                  break;
                }

                _context7.next = 3;
                return this.connect();

              case 3:
                return _context7.abrupt("return", this.getProvider().getSigner());

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getSigner() {
        return _getSigner.apply(this, arguments);
      }

      return getSigner;
    }()
  }, {
    key: "isAuthorized",
    value: function () {
      var _isAuthorized = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        var account;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.prev = 0;
                _context8.next = 3;
                return this.getAccount();

              case 3:
                account = _context8.sent;
                return _context8.abrupt("return", !!account);

              case 7:
                _context8.prev = 7;
                _context8.t0 = _context8["catch"](0);
                return _context8.abrupt("return", false);

              case 10:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[0, 7]]);
      }));

      function isAuthorized() {
        return _isAuthorized.apply(this, arguments);
      }

      return isAuthorized;
    }()
  }, {
    key: "onAccountsChanged",
    value: function onAccountsChanged(accounts) {
      if (accounts.length === 0) {
        this.emit("disconnect");
      } else {
        this.emit("change", {
          account: utils.getAddress(accounts[0])
        });
      }
    }
  }, {
    key: "isChainUnsupported",
    value: function isChainUnsupported(chainId) {
      return !this.chains.some(function (x) {
        return x.id === chainId;
      });
    }
  }, {
    key: "onChainChanged",
    value: function onChainChanged(chainId) {
      var id = normalizeChainId(chainId);
      var unsupported = this.isChainUnsupported(id);
      this.emit("change", {
        chain: {
          id: id,
          unsupported: unsupported
        }
      });
    }
  }, {
    key: "onDisconnect",
    value: function onDisconnect() {
      this.emit("disconnect");
    }
  }, {
    key: "setConfiguration",
    value: function setConfiguration(configuration) {
      if (configuration) {
        this.configuration = configuration;
        window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(configuration));
      } else {
        this.configuration = undefined;
        window.localStorage.removeItem(LOCAL_STORAGE_KEY);
      }
    }
  }]);

  return MagicConnector;
}(Connector);

var chain = {
  mainnet: {
    id: ChainId.Mainnet,
    name: "Ethereum Mainnet",
    nativeCurrency: NATIVE_TOKENS[ChainId.Mainnet],
    rpcUrls: ["https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://etherscan.io"
    }]
  },
  rinkeby: {
    id: ChainId.Rinkeby,
    name: "Rinkeby",
    nativeCurrency: NATIVE_TOKENS[ChainId.Rinkeby],
    rpcUrls: ["https://rinkeby.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://rinkeby.etherscan.io"
    }],
    testnet: true
  },
  goerli: {
    id: ChainId.Goerli,
    name: "Goerli",
    nativeCurrency: NATIVE_TOKENS[ChainId.Goerli],
    rpcUrls: ["https://goerli.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://goerli.etherscan.io"
    }],
    testnet: true
  },
  polygonMainnet: {
    id: ChainId.Polygon,
    name: "Polygon Mainnet",
    nativeCurrency: NATIVE_TOKENS[ChainId.Polygon],
    rpcUrls: ["https://polygon-rpc.com", "https://rpc-mainnet.matic.network", "https://matic-mainnet.chainstacklabs.com", "https://rpc-mainnet.maticvigil.com", "https://rpc-mainnet.matic.quiknode.pro", "https://matic-mainnet-full-rpc.bwarelabs.com"],
    blockExplorers: [{
      name: "Polygonscan",
      url: "https://polygonscan.com"
    }]
  },
  polygonTestnetMumbai: {
    id: ChainId.Mumbai,
    name: "Mumbai",
    nativeCurrency: NATIVE_TOKENS[ChainId.Mumbai],
    rpcUrls: ["https://matic-mumbai.chainstacklabs.com", "https://rpc-mumbai.maticvigil.com", "https://matic-testnet-archive-rpc.bwarelabs.com"],
    blockExplorers: [{
      name: "PolygonScan",
      url: "https://mumbai.polygonscan.com"
    }],
    testnet: true
  },
  avalanche: {
    id: ChainId.Avalanche,
    name: "Avalanche",
    nativeCurrency: NATIVE_TOKENS[ChainId.Avalanche],
    rpcUrls: ["https://api.avax.network/ext/bc/C/rpc", "https://rpc.ankr.com/avalanche"],
    blockExplorers: [{
      name: "SnowTrace",
      url: "https://snowtrace.io/"
    }],
    testnet: false
  },
  avalancheFujiTestnet: {
    id: ChainId.AvalancheFujiTestnet,
    name: "Avalanche Fuji Testnet",
    nativeCurrency: NATIVE_TOKENS[ChainId.AvalancheFujiTestnet],
    rpcUrls: ["https://api.avax-test.network/ext/bc/C/rpc"],
    blockExplorers: [{
      name: "SnowTrace",
      url: "https://testnet.snowtrace.io/"
    }],
    testnet: true
  },
  fantom: {
    id: ChainId.Fantom,
    name: "Fantom Opera",
    nativeCurrency: NATIVE_TOKENS[ChainId.Fantom],
    rpcUrls: ["https://rpc.ftm.tools"],
    blockExplorers: [{
      name: "FTMscan",
      url: "https://ftmscan.com/"
    }],
    testnet: false
  },
  fantomTestnet: {
    id: ChainId.FantomTestnet,
    name: "Fantom Testnet",
    nativeCurrency: NATIVE_TOKENS[ChainId.FantomTestnet],
    rpcUrls: ["https://rpc.testnet.fantom.network"],
    blockExplorers: [{
      name: "FTMscan",
      url: "https://testnet.ftmscan.com/"
    }],
    testnet: true
  },
  optimism: {
    id: ChainId.Optimism,
    name: "Optimism",
    nativeCurrency: NATIVE_TOKENS[ChainId.Optimism],
    rpcUrls: ["https://mainnet.optimism.io"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://optimistic.etherscan.io/"
    }],
    testnet: false
  },
  optimismTestnet: {
    id: ChainId.OptimismTestnet,
    name: "Optimism Kovan",
    nativeCurrency: NATIVE_TOKENS[ChainId.OptimismTestnet],
    rpcUrls: ["https://kovan.optimism.io"],
    blockExplorers: [{
      name: "Etherscan",
      url: "https://kovan-optimistic.etherscan.io/"
    }],
    testnet: true
  },
  arbitrum: {
    id: ChainId.Arbitrum,
    name: "Arbitrum One",
    nativeCurrency: NATIVE_TOKENS[ChainId.Arbitrum],
    rpcUrls: ["https://arb1.arbitrum.io/rpc"],
    blockExplorers: [{
      name: "Arbiscan",
      url: "https://arbiscan.io/"
    }],
    testnet: false
  },
  arbitrumTestnet: {
    id: ChainId.ArbitrumTestnet,
    name: "Arbitrum Rinkeby",
    nativeCurrency: NATIVE_TOKENS[ChainId.ArbitrumTestnet],
    rpcUrls: ["https://rinkeby.arbitrum.io/rpc"],
    blockExplorers: [{
      name: "Arbiscan",
      url: "https://testnet.arbiscan.io/"
    }],
    testnet: true
  }
};
var defaultSupportedChains = Object.values(chain);
function getChainFromChainId(chainId) {
  return defaultSupportedChains.find(function (c) {
    return c.id === chainId;
  });
}

var ThirdwebAuthConfigContext = /*#__PURE__*/createContext(undefined);
var ThirdwebAuthConfigProvider = function ThirdwebAuthConfigProvider(_ref) {
  var value = _ref.value,
      children = _ref.children;
  // Remove trailing slash from URL if present
  var authConfig = useMemo(function () {
    return value ? _objectSpread2(_objectSpread2({}, value), {}, {
      authUrl: value.authUrl.replace(/\/$/, "")
    }) : undefined;
  }, [value]);
  return /*#__PURE__*/jsx(ThirdwebAuthConfigContext.Provider, {
    value: authConfig,
    children: children
  });
};
function useThirdwebAuthConfig() {
  return useContext(ThirdwebAuthConfigContext);
}

var _defaultChainRpc;
var defaultChainRpc = (_defaultChainRpc = {}, _defineProperty(_defaultChainRpc, ChainId.Mainnet, "mainnet"), _defineProperty(_defaultChainRpc, ChainId.Rinkeby, "rinkeby"), _defineProperty(_defaultChainRpc, ChainId.Goerli, "goerli"), _defineProperty(_defaultChainRpc, ChainId.Polygon, "polygon"), _defineProperty(_defaultChainRpc, ChainId.Mumbai, "mumbai"), _defineProperty(_defaultChainRpc, ChainId.Fantom, "fantom"), _defineProperty(_defaultChainRpc, ChainId.Avalanche, "avalanche"), _defaultChainRpc);
var ThirdwebConfigContext = /*#__PURE__*/createContext({
  rpcUrlMap: defaultChainRpc,
  supportedChains: defaultSupportedChains
});
var ThirdwebConfigProvider = function ThirdwebConfigProvider(_ref) {
  var value = _ref.value,
      children = _ref.children;
  return /*#__PURE__*/jsx(ThirdwebConfigContext.Provider, {
    value: value,
    children: children
  });
};
function useThirdwebConfigContext() {
  return useContext(ThirdwebConfigContext);
}

/**
 *
 * @internal
 */

function useSigner() {
  var _account$data, _network$data$chain, _account$data2, _network$data, _network$data$chain2;

  var _useWagmiSigner = useSigner$1(),
      _useWagmiSigner2 = _slicedToArray(_useWagmiSigner, 2),
      signer = _useWagmiSigner2[0],
      getSigner = _useWagmiSigner2[1];

  var _useAccount = useAccount(),
      _useAccount2 = _slicedToArray(_useAccount, 1),
      account = _useAccount2[0];

  var _useNetwork = useNetwork$1(),
      _useNetwork2 = _slicedToArray(_useNetwork, 1),
      network = _useNetwork2[0];

  var _getSignerPromise = useRef(null);

  var address = (_account$data = account.data) === null || _account$data === void 0 ? void 0 : _account$data.address;
  var chainId = (_network$data$chain = network.data.chain) === null || _network$data$chain === void 0 ? void 0 : _network$data$chain.id;
  var previousAddress = usePrevious((_account$data2 = account.data) === null || _account$data2 === void 0 ? void 0 : _account$data2.address);
  var previousChainId = usePrevious((_network$data = network.data) === null || _network$data === void 0 ? void 0 : (_network$data$chain2 = _network$data.chain) === null || _network$data$chain2 === void 0 ? void 0 : _network$data$chain2.id);
  useEffect(function () {
    if (address !== previousAddress || chainId !== previousChainId) {
      if (!_getSignerPromise.current) {
        return;
      } else {
        _getSignerPromise.current = getSigner()["finally"](function () {
          _getSignerPromise.current = null;
        });
      }
    }
  }, [address, chainId, previousAddress, previousChainId]);
  return Signer.isSigner(signer.data) ? signer.data : undefined;
}

function usePrevious(value) {
  // The ref object is a generic container whose current property is mutable ...
  // ... and can hold any value, similar to an instance property on a class
  var ref = useRef(); // Store current value in ref

  useEffect(function () {
    ref.current = value;
  }, [value]); // Only re-run if value changes
  // Return previous value (happens before update in useEffect above)

  return ref.current;
}

var _excluded$8 = ["children"];
// SDK handles this under the hood for us
var defaultdAppMeta = {
  name: "thirdweb powered dApp"
};
var defaultWalletConnectors = ["metamask", "walletConnect", "walletLink"];
/**
 *
 * The `<ThirdwebProvider />` component lets you control what networks you want users to connect to, what types of wallets can connect to your app, and the settings for the [Typescript SDK](https://docs.thirdweb.com/typescript).
 *
 * @example
 * You can wrap your application with the provider as follows:
 *
 * ```jsx title="App.jsx"
 * import { ThirdwebProvider, ChainId } from "@thirdweb-dev/react";
 *
 * const App = () => {
 *   return (
 *     <ThirdwebProvider desiredChainId={ChainId.Mainnet}>
 *       <YourApp />
 *     </ThirdwebProvider>
 *   );
 * };
 * ```
 *
 * @public
 *
 */

var ThirdwebProvider = function ThirdwebProvider(_ref) {
  var sdkOptions = _ref.sdkOptions,
      _ref$chainRpc = _ref.chainRpc,
      chainRpc = _ref$chainRpc === void 0 ? defaultChainRpc : _ref$chainRpc,
      _ref$supportedChains = _ref.supportedChains,
      supportedChains = _ref$supportedChains === void 0 ? defaultSupportedChains.map(function (c) {
    return c.id;
  }) : _ref$supportedChains,
      _ref$walletConnectors = _ref.walletConnectors,
      walletConnectors = _ref$walletConnectors === void 0 ? defaultWalletConnectors : _ref$walletConnectors,
      _ref$dAppMeta = _ref.dAppMeta,
      dAppMeta = _ref$dAppMeta === void 0 ? defaultdAppMeta : _ref$dAppMeta,
      desiredChainId = _ref.desiredChainId,
      authConfig = _ref.authConfig,
      storageInterface = _ref.storageInterface,
      queryClient = _ref.queryClient,
      _ref$autoConnect = _ref.autoConnect,
      autoConnect = _ref$autoConnect === void 0 ? true : _ref$autoConnect,
      children = _ref.children;

  // construct the wagmi options
  var _supporrtedChains = useMemo(function () {
    return supportedChains.map(function (c) {
      if (typeof c === "number") {
        return defaultSupportedChains.find(function (sc) {
          return sc.id === c;
        });
      }

      return c;
    }).filter(function (c) {
      return c !== undefined;
    });
  }, [supportedChains]);

  var _rpcUrlMap = useMemo(function () {
    return _supporrtedChains.reduce(function (prev, curr) {
      prev[curr.id] = curr.id in chainRpc ? getProviderForNetwork(chainRpc[curr.id] || curr.rpcUrls[0]) : curr.rpcUrls[0];
      return prev;
    }, {});
  }, [chainRpc, _supporrtedChains]);

  var wagmiProps = useMemo(function () {
    var walletConnectClientMeta = {
      name: dAppMeta.name,
      url: dAppMeta.url || "",
      icons: [dAppMeta.logoUrl || ""],
      description: dAppMeta.description || ""
    };
    var walletLinkClientMeta = {
      appName: dAppMeta.name,
      appLogoUrl: dAppMeta.logoUrl,
      darkMode: dAppMeta.isDarkMode
    };
    return {
      autoConnect: autoConnect,
      connectorStorageKey: "tw:provider:connectors",
      connectors: function connectors(_ref2) {
        var chainId = _ref2.chainId;
        return walletConnectors.map(function (connector) {
          // injected connector
          if (typeof connector === "string" && (connector === "injected" || connector === "metamask") || _typeof(connector) === "object" && (connector.name === "injected" || connector.name === "metamask")) {
            return new InjectedConnector({
              options: typeof connector === "string" ? {
                shimDisconnect: true,
                shimChainChangedDisconnect: true
              } : connector.options,
              chains: _supporrtedChains
            });
          }

          if (typeof connector === "string" && connector === "walletConnect" || _typeof(connector) === "object" && connector.name === "walletConnect") {
            return new WalletConnectConnector({
              options: typeof connector === "string" ? {
                chainId: chainId,
                rpc: _rpcUrlMap,
                clientMeta: walletConnectClientMeta,
                qrcode: true
              } : _objectSpread2({
                chainId: chainId,
                rpc: _rpcUrlMap,
                clientMeta: walletConnectClientMeta,
                qrcode: true
              }, connector.options),
              chains: _supporrtedChains
            });
          }

          if (typeof connector === "string" && (connector === "coinbase" || connector === "walletLink") || _typeof(connector) === "object" && (connector.name === "coinbase" || connector.name === "walletLink")) {
            var jsonRpcUrl = _rpcUrlMap[chainId || desiredChainId || 1];
            return new CoinbaseWalletConnector({
              chains: _supporrtedChains,
              options: typeof connector === "string" ? _objectSpread2(_objectSpread2({}, walletLinkClientMeta), {}, {
                jsonRpcUrl: jsonRpcUrl
              }) : _objectSpread2(_objectSpread2({}, walletLinkClientMeta), {}, {
                jsonRpcUrl: jsonRpcUrl
              }, connector.options)
            });
          }

          if (_typeof(connector) === "object" && connector.name === "magic") {
            var _jsonRpcUrl = _rpcUrlMap[chainId || desiredChainId || 1];
            return new MagicConnector({
              chains: _supporrtedChains,
              options: _objectSpread2(_objectSpread2({}, connector.options), {}, {
                network: {
                  rpcUrl: _jsonRpcUrl,
                  chainId: desiredChainId || 1
                },
                rpcUrls: _rpcUrlMap
              })
            });
          }

          if (typeof connector === "string" && connector === "gnosis" || _typeof(connector) === "object" && connector.name === "gnosis") {
            return new GnosisSafeConnector({
              chains: _supporrtedChains
            });
          }

          return null;
        }).filter(function (c) {
          return c !== null;
        });
      }
    };
  }, [walletConnectors, _supporrtedChains, dAppMeta]);
  var readonlySettings = useMemo(function () {
    var _sdkOptions$readonlyS, _sdkOptions$readonlyS2;

    if (sdkOptions !== null && sdkOptions !== void 0 && (_sdkOptions$readonlyS = sdkOptions.readonlySettings) !== null && _sdkOptions$readonlyS !== void 0 && _sdkOptions$readonlyS.rpcUrl && sdkOptions !== null && sdkOptions !== void 0 && (_sdkOptions$readonlyS2 = sdkOptions.readonlySettings) !== null && _sdkOptions$readonlyS2 !== void 0 && _sdkOptions$readonlyS2.chainId) {
      return sdkOptions.readonlySettings;
    }

    if (!desiredChainId) {
      return undefined;
    }

    var rpcUrl = _rpcUrlMap[desiredChainId];

    try {
      rpcUrl = getProviderForNetwork(rpcUrl);
    } catch (e) {
      console.error("failed to configure rpc url for chain: \"".concat(desiredChainId, "\". Did you forget to pass \"desiredChainId\" to the <ThirdwebProvider /> component?")); // cannot set readonly without a valid rpc url

      return undefined;
    }

    return {
      chainId: desiredChainId,
      rpcUrl: rpcUrl
    };
  }, [_rpcUrlMap, desiredChainId]);
  var sdkOptionsWithDefaults = useMemo(function () {
    var opts = sdkOptions;
    return _objectSpread2(_objectSpread2({}, opts), {}, {
      readonlySettings: readonlySettings
    });
  }, [sdkOptions, readonlySettings]);
  return /*#__PURE__*/jsx(ThirdwebConfigProvider, {
    value: {
      rpcUrlMap: _rpcUrlMap,
      supportedChains: _supporrtedChains
    },
    children: /*#__PURE__*/jsx(WagmiProvider, _objectSpread2(_objectSpread2({}, wagmiProps), {}, {
      children: /*#__PURE__*/jsx(ThirdwebSDKProviderWagmiWrapper, {
        queryClient: queryClient,
        desiredChainId: desiredChainId,
        sdkOptions: sdkOptionsWithDefaults,
        storageInterface: storageInterface,
        authConfig: authConfig,
        children: children
      })
    }))
  });
};

var ThirdwebSDKProviderWagmiWrapper = function ThirdwebSDKProviderWagmiWrapper(_ref3) {
  var children = _ref3.children,
      props = _objectWithoutProperties(_ref3, _excluded$8);

  var provider = useProvider();
  var signer = useSigner();
  return /*#__PURE__*/jsx(ThirdwebSDKProvider, _objectSpread2(_objectSpread2({
    signer: signer,
    provider: provider
  }, props), {}, {
    children: children
  }));
};

var ThirdwebSDKContext = /*#__PURE__*/createContext({
  desiredChainId: -1
});

/**
 * A barebones wrapper around the Thirdweb SDK.
 *
 * You can use this in order to be able to pass a provider & signer directly to the SDK.
 *
 * @remarks Utilizing this provider will mean hooks for wallet management are not available, if you need those please use the {@link ThirdwebProvider} instead.
 *
 * @beta
 */
var ThirdwebSDKProvider = function ThirdwebSDKProvider(_ref4) {
  var sdkOptions = _ref4.sdkOptions,
      desiredChainId = _ref4.desiredChainId,
      storageInterface = _ref4.storageInterface,
      provider = _ref4.provider,
      signer = _ref4.signer,
      queryClient = _ref4.queryClient,
      authConfig = _ref4.authConfig,
      children = _ref4.children;
  var queryClientWithDefault = useMemo(function () {
    return queryClient ? queryClient : new QueryClient();
  }, [queryClient]);
  var sdk = useMemo(function () {
    if (!desiredChainId || "object" === "undefined") {
      return undefined;
    }

    var _sdk = new ThirdwebSDK(provider, sdkOptions, storageInterface);

    _sdk._chainId = desiredChainId;
    return _sdk;
  }, [provider, sdkOptions, storageInterface, desiredChainId]);
  useEffect(function () {
    if (signer && sdk && sdk._chainId === desiredChainId) {
      sdk.updateSignerOrProvider(signer);
    }
  }, [signer, sdk, desiredChainId]);
  var ctxValue = useMemo(function () {
    return {
      sdk: sdk,
      desiredChainId: desiredChainId || -1,
      _inProvider: true
    };
  }, [sdk]);
  return /*#__PURE__*/jsx(ThirdwebAuthConfigProvider, {
    value: authConfig,
    children: /*#__PURE__*/jsx(QueryClientProvider, {
      client: queryClientWithDefault,
      children: /*#__PURE__*/jsx(ThirdwebSDKContext.Provider, {
        value: ctxValue,
        children: children
      })
    })
  });
};
/**
 * @internal
 */

function useSDKContext() {
  var ctx = React.useContext(ThirdwebSDKContext);
  invariant(ctx._inProvider, "useSDK must be called from within a ThirdwebProvider, did you forget to wrap your app in a <ThirdwebProvider />?");
  return ctx;
}
/**
 *
 * @returns {@link ThirdwebSDK}
 * Access the instance of the thirdweb SDK created by the ThirdwebProvider
 * to call methods using the connected wallet on the desiredChainId.
 * @example
 * ```javascript
 * const sdk = useSDK();
 * ```
 */


function useSDK() {
  var _useSDKContext = useSDKContext(),
      sdk = _useSDKContext.sdk;

  return sdk;
}
/**
 * @internal
 */

function useDesiredChainId() {
  var _useSDKContext2 = useSDKContext(),
      desiredChainId = _useSDKContext2.desiredChainId;

  return desiredChainId;
}
/**
 * @internal
 */

function useActiveChainId() {
  var sdk = useSDK();
  return sdk === null || sdk === void 0 ? void 0 : sdk._chainId;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

var TW_CACHE_KEY_PREFIX = "tw-cache";
/**
 * @internal
 */

function createCachekey(input) {
  if (input[0] === TW_CACHE_KEY_PREFIX) {
    return input;
  }

  return [TW_CACHE_KEY_PREFIX].concat(_toConsumableArray(input));
}
/**
 * @internal
 */


function createContractCacheKey() {
  var contractAddress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : constants.AddressZero;
  var input = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return createCachekey(["contract", contractAddress].concat(_toConsumableArray(input)));
}
/**
 @internal
 */

function createCacheKeyWithNetwork(input, chainId) {
  return cacheKeys.network.active(chainId).concat(input);
}
/**
 * @internal
 */

function invalidateContractAndBalances(queryClient, contractAddress, chainId) {
  return Promise.all([queryClient.invalidateQueries(createCacheKeyWithNetwork(createContractCacheKey(contractAddress), chainId)), queryClient.invalidateQueries(createCacheKeyWithNetwork(createCachekey(["balance"]), chainId))]);
}
/**
 @internal
 */

var cacheKeys = {
  auth: {
    user: function user() {
      return createCachekey(["user"]);
    }
  },
  network: {
    active: function active(chainId) {
      return createCachekey(["chainId", chainId]);
    }
  },
  wallet: {
    balance: function balance(chainId, walletAddress, tokenAddress) {
      return createCacheKeyWithNetwork(createCachekey(["balance", {
        walletAddress: walletAddress,
        tokenAddress: tokenAddress
      }]), chainId);
    }
  },
  contract: {
    type: function type(contractAddress) {
      return createContractCacheKey(contractAddress, ["contract-type"]);
    },
    compilerMetadata: function compilerMetadata(contractAddress) {
      return createContractCacheKey(contractAddress, ["publish-metadata"]);
    },
    typeAndCompilerMetadata: function typeAndCompilerMetadata(contractAddress) {
      return createContractCacheKey(contractAddress, ["contract-type-and-metadata"]);
    },
    metadata: function metadata(contractAddress) {
      return createContractCacheKey(contractAddress, ["metadata"]);
    },
    extractFunctions: function extractFunctions(contractAddress) {
      return createContractCacheKey(contractAddress, ["extractFunctions"]);
    },
    call: function call(contractAddress, functionName, args) {
      return createContractCacheKey(contractAddress, ["call", functionName, args]);
    },
    events: {
      getEvents: function getEvents(contractAddress, eventName) {
        return createContractCacheKey(contractAddress, ["events", "getEvents", {
          eventName: eventName
        }]);
      },
      getAllEvents: function getAllEvents(contractAddress) {
        return createContractCacheKey(contractAddress, ["events", "getAllEvents"]);
      }
    },
    // specific contract types
    nft: {
      get: function get(contractAddress, tokenId) {
        return createContractCacheKey(contractAddress, ["get", {
          tokenId: tokenId
        }]);
      },
      balanceOf: function balanceOf(contractAddress, owner, tokenId) {
        return createContractCacheKey(contractAddress, ["balanceOf", {
          owner: owner,
          tokenId: tokenId
        }]);
      },
      query: {
        all: function all(contractAddress, params) {
          return createContractCacheKey(contractAddress, params ? ["query", "all", params] : ["query", "all"]);
        },
        totalCirculatingSupply: function totalCirculatingSupply(contractAddress) {
          return createContractCacheKey(contractAddress, ["query", "totalCirculatingSupply"]);
        },
        totalCount: function totalCount(contractAddress) {
          return createContractCacheKey(contractAddress, ["query", "totalCount"]);
        },
        owned: {
          all: function all(contractAddress, owner) {
            return createContractCacheKey(contractAddress, ["query", "owned", "all", owner]);
          }
        }
      },
      drop: {
        getAllUnclaimed: function getAllUnclaimed(contractAddress, params) {
          return createContractCacheKey(contractAddress, params ? ["getAllUnclaimed", params] : ["getAllUnclaimed"]);
        },
        totalUnclaimedSupply: function totalUnclaimedSupply(contractAddress) {
          return createContractCacheKey(contractAddress, ["totalUnclaimedSupply"]);
        },
        totalClaimedSupply: function totalClaimedSupply(contractAddress) {
          return createContractCacheKey(contractAddress, ["totalClaimedSupply"]);
        },
        revealer: {
          getBatchesToReveal: function getBatchesToReveal(contractAddress, params) {
            return createContractCacheKey(contractAddress, params ? ["getBatchesToReveal", params] : ["getBatchesToReveal"]);
          }
        }
      }
    },
    token: {
      totalSupply: function totalSupply(contractAddress) {
        return createContractCacheKey(contractAddress, ["totalSupply"]);
      },
      balanceOf: function balanceOf(contractAddress, walletAddress) {
        return createContractCacheKey(contractAddress, ["balanceOf", {
          walletAddress: walletAddress
        }]);
      }
    },
    marketplace: {
      getListing: function getListing(contractAddress, listingId) {
        return createContractCacheKey(contractAddress, ["getListing", {
          listingId: listingId
        }]);
      },
      getAllListings: function getAllListings(contractAddress, params) {
        return createContractCacheKey(contractAddress, params ? ["getAllListings", params] : ["getAllListings"]);
      },
      getActiveListings: function getActiveListings(contractAddress, params) {
        return createContractCacheKey(contractAddress, params ? ["getActiveListings", params] : ["getActiveListings"]);
      },
      getBidBufferBps: function getBidBufferBps(contractAddress) {
        return createContractCacheKey(contractAddress, ["getBidBufferBps"]);
      },
      auction: {
        getWinningBid: function getWinningBid(contractAddress, listingId) {
          return createContractCacheKey(contractAddress, ["auction", "getWinningBid", {
            listingId: listingId
          }]);
        },
        getWinner: function getWinner(contractAddress, listingId) {
          return createContractCacheKey(contractAddress, ["auction", "getWinner", {
            listingId: listingId
          }]);
        }
      }
    }
  },
  // extensions
  extensions: {
    claimConditions: {
      getActive: function getActive(contractAddress, tokenId) {
        return createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "getActive", {
          tokenId: tokenId
        }] : ["claimConditions", "getActive"]);
      },
      getAll: function getAll(contractAddress, tokenId) {
        return createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "getAll", {
          tokenId: tokenId
        }] : ["claimConditions", "getAll"]);
      },
      getClaimIneligibilityReasons: function getClaimIneligibilityReasons(contractAddress, params, tokenId) {
        return createContractCacheKey(contractAddress, tokenId ? ["claimConditions", "getIneligibilityReasons", {
          tokenId: tokenId
        }, params] : ["claimConditions", "getIneligibilityReasons", params]);
      }
    },
    // primary sale contracts
    sales: {
      getRecipient: function getRecipient(contractAddress) {
        return createContractCacheKey(contractAddress, ["sales"]);
      }
    },
    // royalties
    royalties: {
      getDefaultRoyaltyInfo: function getDefaultRoyaltyInfo(contractAddress) {
        return createContractCacheKey(contractAddress, ["royalties"]);
      }
    },
    // platform fees
    platformFees: {
      get: function get(contractAddress) {
        return createContractCacheKey(contractAddress, ["platformFees"]);
      }
    },
    // contract metadata
    metadata: {
      get: function get(contractAddress) {
        return createContractCacheKey(contractAddress, ["metadata"]);
      }
    },
    roles: {
      getAll: function getAll(contractAddress) {
        return createContractCacheKey(contractAddress, ["roles"]);
      },
      get: function get(contractAddress, role) {
        return createContractCacheKey(contractAddress, ["roles", {
          role: role
        }]);
      }
    }
  }
};

/**
 * Hook to securely login to a backend with the connected wallet. The backend
 * authentication URL must be configured on the ThirdwebProvider.
 *
 * @param config - Configuration for the login.
 * @returns - A function to invoke to login with the connected wallet.
 *
 * @beta
 */
function useLogin(config) {
  var sdk = useSDK();
  var queryClient = useQueryClient();
  var authConfig = useThirdwebAuthConfig();
  React.useEffect(function () {
    var queryParams = new URLSearchParams(window.location.search);
    var error = queryParams.get("error");

    if (error && config !== null && config !== void 0 && config.onError) {
      // If there is an error, parse it and trigger the onError callback
      config.onError(decodeURI(error));
    }
  }, [config === null || config === void 0 ? void 0 : config.onError]);

  function login(_x) {
    return _login.apply(this, arguments);
  }

  function _login() {
    _login = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(cfg) {
      var payload, encodedPayload, encodedRedirectTo;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              invariant(authConfig, "Please specify an authConfig in the ThirdwebProvider");
              _context.next = 3;
              return sdk === null || sdk === void 0 ? void 0 : sdk.auth.login(authConfig.domain, cfg);

            case 3:
              payload = _context.sent;
              encodedPayload = encodeURIComponent(btoa(JSON.stringify(payload)));
              encodedRedirectTo = encodeURIComponent((config === null || config === void 0 ? void 0 : config.redirectTo) || authConfig.loginRedirect || window.location.toString());
              queryClient.invalidateQueries(cacheKeys.auth.user()); // Redirect to the login URL with the encoded payload

              window.location.href = "".concat(authConfig.authUrl, "/login?payload=").concat(encodedPayload, "&redirect=").concat(encodedRedirectTo);

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _login.apply(this, arguments);
  }

  return login;
}

/**
 * Hook to logout the connected wallet from the backend.
 * The backend logout URL must be configured on the ThirdwebProvider.
 *
 * @returns - A function to invoke to logout.
 *
 * @beta
 */

function useLogout() {
  var queryClient = useQueryClient();
  var authConfig = useThirdwebAuthConfig();

  function logout() {
    invariant(authConfig, "Please specify an authConfig in the ThirdwebProvider");
    queryClient.invalidateQueries(cacheKeys.auth.user());
    window.location.href = "".concat(authConfig.authUrl, "/logout");
  }

  return logout;
}

/**
 * Hook to get the currently logged in user.
 *
 * @returns - The currently logged in user or null if not logged in, as well as a loading state.
 *
 * @beta
 */
function useUser() {
  var authConfig = useThirdwebAuthConfig();

  var _useQuery = useQuery(cacheKeys.auth.user(), /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var res;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            invariant(authConfig, "Please specify an authConfig in the ThirdwebProvider");
            _context.next = 3;
            return fetch("".concat(authConfig.authUrl, "/user"));

          case 3:
            res = _context.sent;
            _context.next = 6;
            return res.json();

          case 6:
            return _context.abrupt("return", _context.sent);

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }))),
      user = _useQuery.data,
      isLoading = _useQuery.isLoading;

  return {
    user: user,
    isLoading: isLoading
  };
}

/**
 * @internal
 * @param contractType - the contract type
 * @param contractAddress - the contract address
 * @returns the instance of the contract for the given type and address
 */
function useBuiltinContract(contractType, contractAddress) {
  var sdk = useSDK();

  if (!sdk || !contractAddress || !contractType) {
    return undefined;
  }

  return sdk.getBuiltInContract(contractAddress, contractType);
}

/**
 * Hook for getting an instance of an `EditionDrop` contract. This conract is used to interface with ERC1155 compliant NFTs that can be lazily minted.
 * @param contractAddress - the address of the Edition Drop contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useEditionDrop } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const editionDrop = useEditionDrop("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the edition drop contract in the rest of the component
 *
 *   // For example, this function will let the connected wallet claim a new NFT
 *   async function claim(tokenId, quantity) {
 *     await editionDrop.claim(tokenId, quantity)
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 */
function useEditionDrop(contractAddress) {
  return useBuiltinContract("edition-drop", contractAddress);
}

/**
 * Hook for getting an instance of an `Edition` contract. This contract is used to interface with ERC1155 compliant NFTs.
 * @param contractAddress - the address of the Edition contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useEdition } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const edition = useEdition("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the edition contract in the rest of the component
 *
 *   // For example, this function will return all the NFTs on this contract
 *   async function getNFTs() {
 *     const nfts = await edition.getAll()
 *     return nfts
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 */
function useEdition(contractAddress) {
  return useBuiltinContract("edition", contractAddress);
}

/**
 * Hook for getting an instance of an `NFTDrop` contract. This contract is meant to interface with ERC721 compliant NFTs that can be lazily minted.
 * @param contractAddress - the address of the NFT Drop contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useNFTDrop } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const nftDrop = useNFTDrop("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the nft drop contract in the rest of the component
 *
 *   // For example, this function will let the connected wallet claim a new NFT
 *   async function claim(quantity) {
 *     await nftDrop.claim(quantity)
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 */
function useNFTDrop(contractAddress) {
  return useBuiltinContract("nft-drop", contractAddress);
}

/**
 * Hook for getting an instance of a `Marketplace` contract. This contract is used to support marketplace for purchase and sale of on-chain assets.
 * @param contractAddress - the address of the Marketplace contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useMarketplace } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const marketplace = useMarketplace("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the marketplace contract in the rest of the component
 *
 *   // For example, this function will return all the listings on the marketplace
 *   async function getListings() {
 *     const listings = await marketplace.getAll()
 *     return listings
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 */
function useMarketplace(contractAddress) {
  return useBuiltinContract("marketplace", contractAddress);
}

/**
 * Hook for getting an instance of an `NFTCollection` contract. This contract is meant to interface with ERC721 compliant NFTs.
 * @param contractAddress - the address of the NFT Collection contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useNFTCollection } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const nftCollection = useNFTCollection("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the nftCollection contract in the rest of the component
 *
 *   // For example, this function will return all the NFTs on this contract
 *   async function getNFTs() {
 *     const nfts = await nftCollection.getAll()
 *     return nfts
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 */
function useNFTCollection(contractAddress) {
  return useBuiltinContract("nft-collection", contractAddress);
}

/**
 * Hook for getting an instance of a `Pack` contract. This contract supports the creation of on-chain luck-based lootboxes.
 * @param contractAddress - the address of the Pack contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { usePack } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const pack = usePack("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the pack contract in the rest of the component
 *
 *   // For example, this function will get all the packs on this contract
 *   async function getPacks() {
 *     const packs = await pack.getAll()
 *     return packs
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 */
function usePack(contractAddress) {
  return useBuiltinContract("pack", contractAddress);
}

/**
 * Hook for getting an instance of a `Token` contract. This contract supports ERC20 compliant tokens.
 * @param contractAddress - the address of the Token contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useToken } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const token = useToken("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the token contract in the rest of the component
 *
 *   // For example, this function will get the connected wallets token balance
 *   async function balance() {
 *     const balance = await token.balance()
 *     return balance
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 */
function useToken(contractAddress) {
  return useBuiltinContract("token", contractAddress);
}

/**
 * Hook for getting an instance of a `Token Drop` contract.
 * @param contractAddress - the address of the Token Drop contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useTokenDrop } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const tokenDrop = useTokenDrop("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the token drop contract in the rest of the component
 *
 *   // For example, this function will get the connected wallets token balance
 *   async function balance() {
 *     const balance = await tokenDrop.balance()
 *     return balance
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 */
function useTokenDrop(contractAddress) {
  return useBuiltinContract("token-drop", contractAddress);
}

/**
 * Hook for getting an instance of an `Vote` contract. This contract enables fully featured voting-based decentralized governance systems.
 * @param contractAddress - the address of the Vote contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useVote } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const vote = useVote("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the vote contract in the rest of the component
 *
 *   // For example, this function will get all the proposals on this contract
 *   async function getProposals() {
 *     const proposals = await vote.getAll()
 *     return proposals
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 */
function useVote(contractAddress) {
  return useBuiltinContract("vote", contractAddress);
}

/**
 * Hook for getting an instance of a `Split` contract. This contract supports fund distribution to multiple parties.
 * @param contractAddress - the address of the Split contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useSplit } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const split = useSplit("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the split contract in the rest of the component
 *
 *   // For example, this function will retrun all the receipients of the split
 *   async function getRecipients() {
 *     const recipients = await split.getAllRecipients()
 *     return recipients
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 */
function useSplit(contractAddress) {
  return useBuiltinContract("split", contractAddress);
}

/**
 * Hook for getting an instance of an `Multiwrap` contract. This contract is an ERC721 in which you can wrap ERC721, ERC1155 and ERC20 tokens.
 * @param contractAddress - the address of the Multiwrap contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useMultiwrap } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const multiwrap = useMultiwrap("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the multiwrap contract in the rest of the component
 *
 *   // For example, this function will let the connected wallet wrap tokens
 *   async function wrap(tokensToWrap, wrappedNFTMetadata) {
 *     await multiwrap.wrap(tokensToWrap, wrappedNFTMetadata)
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 */
function useMultiwrap(contractAddress) {
  return useBuiltinContract("multiwrap", contractAddress);
}

/**
 * Hook for getting an instance of an `SignatureDrop` contract. This contract is meant to interface with ERC721 compliant NFTs that can be lazily minted.
 * @param contractAddress - the address of the NFT Drop contract, found in your thirdweb dashboard
 *
 * @example
 * ```javascript
 * import { useSignatureDrop } from '@thirdweb-dev/react'
 *
 * export default function Component() {
 *   const signatureDrop = useSignatureDrop("<YOUR-CONTRACT-ADDRESS>")
 *
 *   // Now you can use the Signature drop contract in the rest of the component
 *
 *   // For example, this function will let the connected wallet claim a new NFT
 *   async function claim(quantity) {
 *     await signatureDrop.claim(quantity)
 *   }
 *
 *   ...
 * }
 * ```
 * @public
 */
function useSignatureDrop(contractAddress) {
  return useBuiltinContract("signature-drop", contractAddress);
}

/**
 * for now just re-exported
 * @internal
 */

function useConnect() {
  return useConnect$1();
}

/**
 * Hook for disconnecting the currently connected wallet
 *
 * ```javascript
 * import { useDisconnect } from "@thirdweb-dev/react"
 * ```
 *
 *
 * @example
 * The following will enable users to disconnect their wallet from the page.
 * ```javascript
 * import { useDisconnect } from "@thirdweb-dev/react"
 *
 * const App = () => {
 *   const disconnect = useDisconnect()
 *
 *   return (
 *     <button onClick={disconnect}>
 *       Disconnect
 *     </button>
 *   )
 * }
 * ```
 *
 * Once users disconnect their wallet, the `useAddress`, `useChainId`, `useAccount`, and `useNetwork` hooks will no longer return values until a user connects their wallet again.
 *
 * @public
 */

function useDisconnect(options) {
  var optsWithDefaults = _objectSpread2(_objectSpread2({}, {
    reconnectAfterGnosis: true
  }), options);

  var _useConnect = useConnect(),
      _useConnect2 = _slicedToArray(_useConnect, 2),
      connect = _useConnect2[1];

  var _useAccount = useAccount(),
      _useAccount2 = _slicedToArray(_useAccount, 2),
      data = _useAccount2[0],
      disconnect = _useAccount2[1];

  return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var _data$data;

    var previousConnector;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            previousConnector = ((_data$data = data.data) === null || _data$data === void 0 ? void 0 : _data$data.connector) instanceof GnosisSafeConnector && data.data.connector.previousConnector || undefined; // if it's gnosis, just connect the previous connector

            if (!(optsWithDefaults.reconnectAfterGnosis && previousConnector)) {
              _context.next = 12;
              break;
            }

            _context.prev = 2;
            _context.next = 5;
            return connect(previousConnector);

          case 5:
            return _context.abrupt("return", _context.sent);

          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](2);
            console.error("failed to re-connect to previous connector", _context.t0); // if it fails for whatever reason just disconnect

            return _context.abrupt("return", disconnect());

          case 12:
            return _context.abrupt("return", disconnect());

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[2, 8]]);
  }));
}

/**
 * Hook for accessing the address of the connected wallet
 *
 * ```javascript
 * import { useAddress } from "@thirdweb-dev/react"
 * ```
 *
 *
 * @example
 * To get the address of the connected wallet, you can use the hook as follows:
 *
 * ```javascript
 * import { useAddress } from "@thirdweb-dev/react"
 *
 * const App = () => {
 *   const address = useAddress()
 *
 *   return <div>{address}</div>
 * }
 * ```
 *
 * The `address` variable will hold the address of the connected wallet if a user has connected using one of the supported wallet connection hooks.
 *
 * @public
 */

function useAddress() {
  var _account$data;

  var _useAccount = useAccount(),
      _useAccount2 = _slicedToArray(_useAccount, 1),
      account = _useAccount2[0];

  return (_account$data = account.data) === null || _account$data === void 0 ? void 0 : _account$data.address;
}

/**
 * @internal
 */

function useReadonlySDK(readonlyRpcUrl, sdkOptions, storageInterface) {
  return useMemo(function () {
    return new ThirdwebSDK(readonlyRpcUrl, _objectSpread2(_objectSpread2({}, sdkOptions), {}, {
      readonlySettings: _objectSpread2(_objectSpread2({}, sdkOptions === null || sdkOptions === void 0 ? void 0 : sdkOptions.readonlySettings), {}, {
        rpcUrl: readonlyRpcUrl
      })
    }), storageInterface);
  }, [readonlyRpcUrl, sdkOptions]);
}

function detectEnv(userAgent) {
  return detect(userAgent);
}
/**
 * @internal
 */


function isAndroid() {
  var os = detectOS();
  return os ? os.toLowerCase().includes("android") : false;
}
/**
 * @internal
 */

function isIOS() {
  var os = detectOS();
  return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
/**
 * @internal
 */

function detectOS() {
  var env = detectEnv();
  return env !== null && env !== void 0 && env.os ? env.os : undefined;
}
/**
 * @internal
 */


function isMobile() {
  var os = detectOS();
  return os ? isAndroid() || isIOS() : false;
}

/**
 * Hook for connecting to a Metamask wallet.
 *
 * ```javascript
 * import { useMetamask } from "@thirdweb-dev/react"
 * ```
 *
 *
 * @example
 * We can allow users to connect their metamask wallets as follows:
 * ```javascript
 * import { useMetamask } from "@thirdweb-dev/react"
 *
 * const App = () => {
 *   const connectWithMetamask = useMetamask()
 *
 *   return (
 *     <button onClick={connectWithMetamask}>
 *       Connect Metamask
 *     </button>
 *   )
 * }
 * ```
 * Here, we use the `useMetamask` hook to handle metamask connection.
 * When a user clicks the button, we'll call the `connectWithMetamask` function, which will prompt users to connect their metamask wallet.
 *
 * @public
 */

function useMetamask() {
  var _window$ethereum;

  var _useConnect = useConnect(),
      _useConnect2 = _slicedToArray(_useConnect, 2),
      connectors = _useConnect2[0],
      connect = _useConnect2[1];

  var isMetaMaskInjected = ((_window$ethereum = window.ethereum) === null || _window$ethereum === void 0 ? void 0 : _window$ethereum.isMetaMask);
  var shouldUseWalletConnect = isMobile() && !isMetaMaskInjected; // injected connector

  var injectedConnector = connectors.data.connectors.find(function (c) {
    return c.id === "injected";
  }); // walletConnect connector

  var walletConnectConnector = connectors.data.connectors.find(function (c) {
    return c.id === "walletConnect";
  });
  var connector = (shouldUseWalletConnect ? walletConnectConnector : injectedConnector) || injectedConnector;
  invariant(connector, "No connector found, please make sure you provide the InjectedConnector to your <ThirdwebProvider />");
  return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var uri;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (isMetaMaskInjected) {
              _context.next = 15;
              break;
            }

            // this is the fallback uri that should work no matter what
            uri = "https://metamask.app.link/dapp/".concat(window.location.host + window.location.pathname + window.location.search); // if we have walletconnect etc, we can try to use that

            if (!(shouldUseWalletConnect && connector.id === "walletConnect")) {
              _context.next = 13;
              break;
            }

            _context.prev = 3;
            _context.next = 6;
            return connector.getProvider();

          case 6:
            uri = _context.sent.connector.uri;
            // if android we can use the uri straight
            uri = isAndroid() ? uri : // otherwise we have to use /dapp link for now
            "https://metamask.app.link/dapp/".concat(window.location.host + window.location.pathname + window.location.search);
            _context.next = 13;
            break;

          case 10:
            _context.prev = 10;
            _context.t0 = _context["catch"](3);
            console.warn("failed to get provider.connector.uri", _context.t0);

          case 13:
            // open whatever uri we end up with in a new tab
            window.open(uri, "_blank");
            return _context.abrupt("return", Promise.resolve({
              error: new Error("metamask not injected")
            }));

          case 15:
            _context.next = 17;
            return connect(connector);

          case 17:
            return _context.abrupt("return", _context.sent);

          case 18:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[3, 10]]);
  }));
}

/**
 * Hook for connecting to a mobile wallet with Wallet Connect
 *
 * ```javascript
 * import { useWalletConnect } from "@thirdweb-dev/react"
 * ```
 *
 *
 * @example
 * We can allows user to connect their mobile wallets as follows:
 * ```javascript
 * import { useWalletConnect } from "@thirdweb-dev/react"
 *
 * const App = () => {
 *   const connectWithWalletConnect = useWalletConnect()
 *
 *   return (
 *     <button onClick={connectWithWalletConnect}>
 *       Connect WalletConnect
 *     </button>
 *   )
 * }
 * ```
 *
 * When users click this button, a popup will appear on the screen prompting them to scan a QR code from their phone to connect their mobile wallets.
 * Once they scan the QR code from a wallet connect supported mobile wallet, their wallet will then be connected to the page as expected.
 *
 * @public
 */

function useWalletConnect() {
  var _useConnect = useConnect(),
      _useConnect2 = _slicedToArray(_useConnect, 2),
      connectors = _useConnect2[0],
      connect = _useConnect2[1];

  if (connectors.loading) {
    return function () {
      return Promise.reject("WalletConnect connector not ready to be used, yet");
    };
  }

  var connector = connectors.data.connectors.find(function (c) {
    return c.id === "walletConnect";
  });
  invariant(connector, "WalletConnect connector not found, please make sure it is provided to your <ThirdwebProvider />");
  return function () {
    return connect(connector);
  };
}

/**
 * Hook for connecting to a Coinbase wallet.
 *
 * ```javascript
 * import { useCoinbaseWallet } from "@thirdweb-dev/react"
 * ```
 *
 *
 * @example
 * We can allow users to connect with Coinbase Wallet as follows:
 * ```javascript
 * import { useCoinbaseWallet } from "@thirdweb-dev/react"
 *
 * const App = () => {
 *   const connectWithCoinbaseWallet = useCoinbaseWallet()
 *
 *   return (
 *     <button onClick={connectWithCoinbaseWallet}>
 *       Connect Coinbase Wallet
 *     </button>
 *   )
 * }
 * ```
 *
 * Upon clicking this button, users will be prompted with a popup asking them scan a QR code with their Coinbase Wallet.
 * Once they scan the QR code, their wallet will then be connected to the page as expected.
 *
 * @public
 */

function useCoinbaseWallet() {
  var _useConnect = useConnect(),
      _useConnect2 = _slicedToArray(_useConnect, 2),
      connectors = _useConnect2[0],
      connect = _useConnect2[1];

  if (connectors.loading) {
    return function () {
      return Promise.reject("Coinbase connector not ready to be used, yet");
    };
  }

  var connector = connectors.data.connectors.find(function (c) {
    return c.id === "coinbasewallet";
  });
  invariant(connector, "Coinbase connector not found, please make sure it is provided to your <ThirdwebProvider />");
  return function () {
    return connect(connector);
  };
}
/**
 * Convienience hook for connecting to a wallet via WalletLink (coinbase wallet)
 * @returns a function that will prompt the user to connect their wallet via WalletLink (coinbase wallet)
 * @internal
 */

function useWalletLink() {
  return useCoinbaseWallet();
}

/**
 * Hook for connecting to a Gnosis Safe. This enables multisig wallets to connect to your application and sing transactions.
 *
 * ```javascript
 * import { useGnosis } from "@thirdweb-dev/react"
 * ```
 *
 *
 * @example
 * ```javascript
 * import { useGnosis } from "@thirdweb-dev/react"
 *
 * const App = () => {
 *   const connectWithGnosis = useGnosis()
 *
 *   return (
 *     <button onClick={() => connectWithGnosis({ safeAddress: "0x...", safeChainId: 1 })}>
 *       Connect Gnosis Safe
 *     </button>
 *   )
 * }
 * ```
 *
 * @public
 */

function useGnosis() {
  var _useConnect = useConnect(),
      _useConnect2 = _slicedToArray(_useConnect, 2),
      connectors = _useConnect2[0],
      connect = _useConnect2[1];

  if (connectors.loading) {
    return function () {
      return Promise.reject("Gnosis connector not ready to be used, yet");
    };
  }

  var connector = connectors.data.connectors.find(function (c) {
    return c.id === "gnosis";
  });
  invariant(connector, "Gnosis connector not found, please make sure it is provided to your <ThirdwebProvider />");
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(config) {
      var previousConnector, previousConnectorChain;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              previousConnector = connectors.data.connector;
              _context.next = 3;
              return previousConnector === null || previousConnector === void 0 ? void 0 : previousConnector.getChainId();

            case 3:
              previousConnectorChain = _context.sent;
              invariant(!!previousConnector, "Cannot connect to Gnosis Safe without first being connected to a personal wallet.");
              invariant(previousConnectorChain === config.safeChainId, "Gnosis safe chain id must match personal wallet chain id.");
              invariant(utils.isAddress(config.safeAddress), "Gnosis safe address must be a valid address.");
              connector.setConfiguration(previousConnector, config);
              return _context.abrupt("return", connect(connector));

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();
}

/**
 * Hook for connecting to an email wallet using magic link.
 * This enables users without their own wallets to connect to your application and sign transactions securely using their email.
 *
 * ```javascript
 * import { useMagic } from "@thirdweb-dev/react"
 * ```
 *
 *
 * @example
 * Before using this hook, you first need to set up the magic configuration in your `ThirdwebProvider`, including your magic API key.
 *
 * ```javascript
 * // Add the magic configuration object to your wallet connectors
 * const connectors = [
 *   "metamask",
 *   "walletConnect",
 *   "walletLink",
 *   {
 *     name: "magic",
 *     options: {
 *       apiKey: "your-magic-api-key",
 *     }
 *   }
 * ]
 *
 * // Add the above to the walletConnectors prop of your <ThirdwebProvider />
 * const Provider = ({ children }) => (
 *   return (
 *     <ThirdwebProvider
 *       walletConnectors={connectors}
 *       // Specify remaining parameters
 *       ...
 *     >
 *       {children}
 *     </ThirdwebProvider>
 *   )
 * }
 * ```
 *
 * In order to use the hook to connect users with magic link, you just need to provide the users email to the connect function.
 *
 * You can setup the hook with the following configuration:
 * ```javascript
 * import { useMagic } from "@thirdweb-dev/react"
 * import { useState } from "react"
 *
 * const LoginWithMagicLink = () => {
 *   const connectWithMagic = useMagic()
 *   const [email, setEmail] = useState()
 *
 *   return (
 *     <div>
 *       <input value={email} onChange={(e) => setEmail(e.target.value)} />
 *       <button onClick={() => connectWithMagic({ email })}>Login</button>
 *     </div>
 *   )
 * }
 * ```
 *
 * @public
 */

function useMagic() {
  var _useConnect = useConnect(),
      _useConnect2 = _slicedToArray(_useConnect, 2),
      connectors = _useConnect2[0],
      connect = _useConnect2[1];

  if (connectors.loading) {
    return function () {
      return Promise.reject("Magic connector not ready to be used, yet");
    };
  }

  var connector = connectors.data.connectors.find(function (c) {
    return c.id === "magic";
  });
  invariant(connector, "Magic connector not found, please make sure it is provided to your <ThirdwebProvider />");
  return function (configuration) {
    connector.setConfiguration(configuration);
    return connect(connector);
  };
}

/**
 * Hook for accessing the chain ID of the network the current wallet is connected to
 *
 * ```javascript
 * import { useChainId } from "@thirdweb-dev/react"
 * ```
 *
 * @example
 * You can get the chain ID of the connected wallet by using the hook as follows:
 * ```javascript
 * import { useChainId } from "@thirdweb-dev/react"
 *
 * const App = () => {
 *   const chainId = useChainId()
 *
 *   return <div>{chainId}</div>
 * }
 * ```
 * @public
 */

function useChainId() {
  var _useNetwork$0$data$ch;

  return (_useNetwork$0$data$ch = useNetwork$1()["0"].data.chain) === null || _useNetwork$0$data$ch === void 0 ? void 0 : _useNetwork$0$data$ch.id;
}

/**
 * Hook for checking whether the connected wallet is on the correct network specified by the `desiredChainId` passed to the `<ThirdwebProvider />`.
 *
 * ```javascript
 * import { useNetworkMistmatch } from "@thirdweb-dev/react"
 * ```
 *
 * @returns `true` if the chainId of the connected wallet is different from the desired chainId passed into <ThirdwebProvider />
 *
 * @example
 * You can check if a users wallet is connected to the correct chain ID as follows:
 * ```javascript
 * import { useNetworkMismatch } from "@thirdweb-dev/react"
 *
 * const App = () => {
 *   const isMismatched = useNetworkMismatch()
 *
 *   return <div>{isMismatched}</div>
 * }
 * ```
 *
 * From here, you can prompt users to switch their network using the `useNetwork` hook.
 *
 * @public
 */

function useNetworkMismatch() {
  var desiredChainId = useDesiredChainId();
  var activeChainId = useChainId();

  if (desiredChainId === -1) {
    // means no desiredChainId is set in the <ThirdwebProvider />, so we don't care about the network mismatch
    return false;
  }

  if (!activeChainId) {
    // means no wallet is connected yet, so we don't care about the network mismatch
    return false;
  } // check if the chainIds are different


  return desiredChainId !== activeChainId;
}

/**
 * Hook for getting metadata about the network the current wallet is connected to and switching networks
 *
 * @example
 * ```javascript
 * import { useNetwork, ChainId } from "@thirdweb-dev/react";
 *
 * const App = () => {
 *   const [, switchNetwork] = useNetwork();
 *
 *   return (
 *     <button onClick={() => switchNetwork(ChainId.Polygon)}>
 *        Switch Network
 *     </button>
 *   );
 * };
```
 *
 * It's important to note that some wallet apps do not support programmatic network switching and switchNetwork will be undefined.
 * For those situations, you can typically switch networks in the wallet app this hook will still work.
 *
 * @public
 */

function useNetwork() {
  return useNetwork$1();
}

/** @internal */

function useQueryWithNetwork(queryKey, queryFn, options) {
  var activeChainId = useActiveChainId();

  var mergedOptions = _objectSpread2(_objectSpread2({}, options), {}, {
    enabled: !!(activeChainId && options !== null && options !== void 0 && options.enabled)
  });

  return useQuery(createCacheKeyWithNetwork(queryKey, activeChainId), queryFn, mergedOptions);
}

function fetchContractType(_x, _x2) {
  return _fetchContractType.apply(this, arguments);
}

function _fetchContractType() {
  _fetchContractType = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(contractAddress, sdk) {
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!(!contractAddress || !sdk)) {
              _context4.next = 2;
              break;
            }

            return _context4.abrupt("return");

          case 2:
            _context4.prev = 2;
            _context4.next = 5;
            return sdk.resolveContractType(contractAddress);

          case 5:
            return _context4.abrupt("return", _context4.sent);

          case 8:
            _context4.prev = 8;
            _context4.t0 = _context4["catch"](2);
            return _context4.abrupt("return", "custom");

          case 11:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[2, 8]]);
  }));
  return _fetchContractType.apply(this, arguments);
}

function fetchContractCompilerMetadata(_x3, _x4) {
  return _fetchContractCompilerMetadata.apply(this, arguments);
}

function _fetchContractCompilerMetadata() {
  _fetchContractCompilerMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(contractAddress, sdk) {
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (!(!contractAddress || !sdk)) {
              _context5.next = 2;
              break;
            }

            return _context5.abrupt("return");

          case 2:
            _context5.next = 4;
            return sdk.getPublisher();

          case 4:
            _context5.next = 6;
            return _context5.sent.fetchCompilerMetadataFromAddress(contractAddress);

          case 6:
            return _context5.abrupt("return", _context5.sent);

          case 7:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _fetchContractCompilerMetadata.apply(this, arguments);
}

function fetchContractTypeAndCompilerMetadata(_x5, _x6, _x7) {
  return _fetchContractTypeAndCompilerMetadata.apply(this, arguments);
}

function _fetchContractTypeAndCompilerMetadata() {
  _fetchContractTypeAndCompilerMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(queryClient, contractAddress, sdk) {
    var contractType, compilerMetadata;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (!(!contractAddress || !sdk)) {
              _context6.next = 2;
              break;
            }

            return _context6.abrupt("return");

          case 2:
            _context6.next = 4;
            return queryClient.fetchQuery(createCacheKeyWithNetwork(cacheKeys.contract.type(contractAddress), sdk._chainId), function () {
              return fetchContractType(contractAddress, sdk);
            }, // is immutable, so infinite stale time
            {
              staleTime: Infinity
            });

          case 4:
            contractType = _context6.sent;

            if (!(contractType !== "custom")) {
              _context6.next = 7;
              break;
            }

            return _context6.abrupt("return", {
              contractType: contractType,
              compilerMetadata: null
            });

          case 7:
            _context6.next = 9;
            return queryClient.fetchQuery(createCacheKeyWithNetwork(cacheKeys.contract.compilerMetadata(contractAddress), sdk._chainId), function () {
              return fetchContractCompilerMetadata(contractAddress, sdk);
            }, // is immutable, so infinite stale time
            {
              staleTime: Infinity
            });

          case 9:
            compilerMetadata = _context6.sent;
            return _context6.abrupt("return", {
              contractType: contractType,
              compilerMetadata: compilerMetadata
            });

          case 11:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _fetchContractTypeAndCompilerMetadata.apply(this, arguments);
}

function getContractAbi(input) {
  if (!input || !input.contractType) {
    return null;
  }

  var contractAbi = null;

  if (input.contractType !== "custom") {
    contractAbi = CONTRACTS_MAP[input.contractType].contractAbi;
  }

  if (input.contractType === "custom" && input.compilerMetadata) {
    var _input$compilerMetada;

    contractAbi = (_input$compilerMetada = input.compilerMetadata) === null || _input$compilerMetada === void 0 ? void 0 : _input$compilerMetada.abi;
  }

  return contractAbi;
}

function getContractFromCombinedTypeAndCompilerMetadata(contractAddress, input, sdk) {
  if (!input || !sdk || !contractAddress || !input.contractType) {
    return null;
  }

  var contractAbi = getContractAbi(input);
  invariant(contractAbi, "could not resolve any ABI for contract".concat(contractAddress));
  return sdk.getContractFromAbi(contractAddress, contractAbi);
}
/**
 *
 * @internal
 *
 * @param contractAddress - contract address
 * @returns the contract abi
 */


function useContractAbi(contractAddress) {
  var _contractTypeAndCompi;

  var sdk = useSDK();
  var contractTypeAndCompilerMetadata = useContractTypeAndCompilerMetadata(contractAddress);

  if (!contractAddress || !sdk || !((_contractTypeAndCompi = contractTypeAndCompilerMetadata.data) !== null && _contractTypeAndCompi !== void 0 && _contractTypeAndCompi.contractType)) {
    return _objectSpread2(_objectSpread2({}, contractTypeAndCompilerMetadata), {}, {
      abi: null
    });
  }

  var abi = getContractAbi(contractTypeAndCompilerMetadata.data);
  return _objectSpread2(_objectSpread2({}, contractTypeAndCompilerMetadata), {}, {
    abi: abi
  });
}
/**
 * Use this to get the contract type for a (built-in or custom) contract.
 *
 * @example
 * ```javascript
 * const { data: contractType, isLoading, error } = useContractType("{{contract_address}}");
 * ```
 *
 * @param contractAddress - the address of the deployed contract
 * @returns a response object that includes the contract type of the contract
 * @beta
 */

function useContractType(contractAddress) {
  var sdk = useSDK();
  return useQueryWithNetwork(cacheKeys.contract.type(contractAddress), function () {
    return fetchContractType(contractAddress, sdk);
  }, {
    enabled: !!sdk && !!contractAddress,
    // never stale, a contract's publish metadata is immutable
    staleTime: Infinity
  });
}
/**
 * Use this to get the publish metadata for a deployed contract.
 *
 * @example
 * ```javascript
 * const { data: compilerMetadata, isLoading, error } = useContractCompilerMetadata("{{contract_address}}");
 * ```
 *
 * @param contractAddress - the address of the deployed contract
 * @returns a response object that includes the published metadata (name, abi, bytecode) of the contract
 * @beta
 */

function useContractCompilerMetadata(contractAddress) {
  var sdk = useSDK();
  return useQueryWithNetwork(cacheKeys.contract.compilerMetadata(contractAddress), function () {
    return fetchContractCompilerMetadata(contractAddress, sdk);
  }, {
    enabled: !!sdk && !!contractAddress,
    // never stale, a contract's publish metadata is immutable
    staleTime: Infinity
  });
}
/**
 * @internal
 */

function useContractTypeAndCompilerMetadata(contractAddress) {
  var sdk = useSDK();
  var queryClient = useQueryClient();
  return useQueryWithNetwork(cacheKeys.contract.typeAndCompilerMetadata(contractAddress), function () {
    return fetchContractTypeAndCompilerMetadata(queryClient, contractAddress, sdk);
  }, {
    enabled: !!sdk && !!contractAddress,
    // combination of type and publish metadata is immutable
    staleTime: Infinity
  });
}
/**
 * Use this resolve a contract address to a thirdweb (built-in / custom) contract instance.
 *
 * @example
 * ```javascript
 * const { contract, isLoading, error } = useContract("{{contract_address}}");
 * ```
 *
 * @param contractAddress - the address of the deployed contract
 * @returns a response object that includes the contract once it is resolved
 * @beta
 */


function useContract(contractAddress) {
  var _contractTypeAndCompi2;

  var sdk = useSDK();
  var contractTypeAndCompilerMetadata = useContractTypeAndCompilerMetadata(contractAddress);

  if (!contractAddress || !sdk || !((_contractTypeAndCompi2 = contractTypeAndCompilerMetadata.data) !== null && _contractTypeAndCompi2 !== void 0 && _contractTypeAndCompi2.contractType)) {
    return _objectSpread2(_objectSpread2({}, contractTypeAndCompilerMetadata), {}, {
      contract: null
    });
  }

  var contract = getContractFromCombinedTypeAndCompilerMetadata(contractAddress, contractTypeAndCompilerMetadata.data, sdk);
  return _objectSpread2(_objectSpread2({}, contractTypeAndCompilerMetadata), {}, {
    contract: contract
  });
}
/**
 * Use this to get the contract metadata for a (built-in or custom) contract.
 *
 * @example
 * ```javascript
 * const { data: contractMetadata, isLoading, error } = useContractMetadata("{{contract_address}}");
 * ```
 *
 * @param contractAddress - the address of the deployed contract
 * @returns a response object that includes the contract metadata of the deployed contract
 * @beta
 */

function useContractMetadata(contractAddress) {
  var sdk = useSDK();
  var queryClient = useQueryClient();
  var activeChainId = useActiveChainId();
  return useQueryWithNetwork(cacheKeys.contract.metadata(contractAddress), /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var _contract$metadata;

    var typeAndCompilerMetadata, contract;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return queryClient.fetchQuery(createCacheKeyWithNetwork(cacheKeys.contract.typeAndCompilerMetadata(contractAddress), activeChainId), function () {
              return fetchContractTypeAndCompilerMetadata(queryClient, contractAddress, sdk);
            }, // is immutable, so infinite stale time
            {
              staleTime: Infinity
            });

          case 2:
            typeAndCompilerMetadata = _context.sent;
            contract = getContractFromCombinedTypeAndCompilerMetadata(contractAddress, typeAndCompilerMetadata, sdk);
            invariant(contract === null || contract === void 0 ? void 0 : (_contract$metadata = contract.metadata) === null || _contract$metadata === void 0 ? void 0 : _contract$metadata.get, "contract metadata is not available");
            _context.next = 7;
            return contract.metadata.get();

          case 7:
            return _context.abrupt("return", _context.sent);

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })), {
    enabled: !!contractAddress || !!sdk
  });
}
/**
 @internal
 */

function useContractFunctions(contractAddress) {
  var sdk = useSDK();
  var queryClient = useQueryClient();
  var activeChainId = useActiveChainId();
  return useQueryWithNetwork(cacheKeys.contract.extractFunctions(contractAddress), /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var typeAndCompilerMetadata, contract;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return queryClient.fetchQuery(createCacheKeyWithNetwork(cacheKeys.contract.typeAndCompilerMetadata(contractAddress), activeChainId), function () {
              return fetchContractTypeAndCompilerMetadata(queryClient, contractAddress, sdk);
            }, // is immutable, so infinite stale time
            {
              staleTime: Infinity
            });

          case 2:
            typeAndCompilerMetadata = _context2.sent;
            contract = getContractFromCombinedTypeAndCompilerMetadata(contractAddress, typeAndCompilerMetadata, sdk);

            if (!(contract instanceof SmartContract)) {
              _context2.next = 6;
              break;
            }

            return _context2.abrupt("return", contract.publishedMetadata.extractFunctions());

          case 6:
            return _context2.abrupt("return", null);

          case 7:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  })), {
    enabled: !!contractAddress || !!sdk,
    // functions are based on publish metadata (abi), so this is immutable
    staleTime: Infinity
  });
}
/**
 * Use this to get data from a contract read-function call.
 *
 * @example
 * ```javascript
 * const { contract } = useContract("{{contract_address}}");
 * const { data, isLoading, error } = useContractData(contract, "functionName", ...args);
 *```
 *
 * @param contract - the contract instance of the contract to call a function on
 * @param functionName - the name of the function to call
 * @param args - The arguments to pass to the function (if any), with optional call arguments as the last parameter
 * @returns a response object that includes the data returned by the function call
 *
 * @beta
 */

function useContractData(contract, functionName) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.call(contractAddress, functionName, args), function () {
    invariant(contract, "contract must be defined");
    invariant(functionName, "function name must be provided");
    return contract.call.apply(contract, [functionName].concat(args));
  }, {
    enabled: !!contract && !!functionName
  });
}
/**
 * Use this to get a function to make a write call to your contract
 *
 * @example
 * ```javascript
 * const { contract } = useContract("{{contract_address}}");
 * const { mutate: myFunction, isLoading, error } = useContractCall(contract, "myFunction");
 *
 * // the function can be called as follows:
 * // myFunction(["param 1", "param 2", ...])
 *```
 *
 * @param contract - the contract instance of the contract to call a function on
 * @param functionName - the name of the function to call
 * @returns a response object that includes the write function to call
 *
 * @beta
 */

function useContractCall(contract, functionName) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  return useMutation( /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(callParams) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              invariant(contract, "contract must be defined");
              invariant(functionName, "function name must be provided");

              if (callParams !== null && callParams !== void 0 && callParams.length) {
                _context3.next = 4;
                break;
              }

              return _context3.abrupt("return", contract.call(functionName));

            case 4:
              return _context3.abrupt("return", contract.call.apply(contract, [functionName].concat(_toConsumableArray(callParams))));

            case 5:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function (_x8) {
      return _ref3.apply(this, arguments);
    };
  }(), {
    onSettled: function onSettled() {
      return queryClient.invalidateQueries(createCacheKeyWithNetwork(createContractCacheKey(contractAddress), activeChainId));
    }
  });
}
/**
 * Use this to query (and subscribe) to all events on a contract.
 *
 * @param contract - the contract instance of the contract to call a function on
 * @param options - options incldues the filters ({@link QueryAllEvents}) for the query as well as if you want to subscribe to real-time updates (default: true)
 * @returns a response object that includes the contract events
 * @beta
 */

function useAllContractEvents(contract) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    subscribe: true
  };
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryEnabled = !!contract;
  var queryClient = useQueryClient();
  var activeChainId = useActiveChainId();
  var cacheKey = useMemo(function () {
    return createCacheKeyWithNetwork(cacheKeys.contract.events.getAllEvents(contractAddress), activeChainId);
  }, [contractAddress]);
  useEffect(function () {
    // if we're not subscribing or query is not enabled yet we can early exit
    if (!options.subscribe || !queryEnabled || !contract) {
      return;
    }

    var cleanupListener = contract.events.listenToAllEvents(function (contractEvent) {
      // insert new event to the front of the array (no duplicates, though)
      queryClient.setQueryData(cacheKey, function (oldData) {
        if (!oldData) {
          return [contractEvent];
        }

        var eventIsNotAlreadyInEventsList = oldData.findIndex(function (e) {
          return e.transaction.transactionHash === contractEvent.transaction.transactionHash && e.transaction.logIndex === contractEvent.transaction.logIndex;
        }) === -1;

        if (eventIsNotAlreadyInEventsList) {
          return [contractEvent].concat(_toConsumableArray(oldData));
        }

        return oldData;
      });
    }); // cleanup listener on unmount

    return cleanupListener;
  }, [queryEnabled, options.subscribe, cacheKey]);
  return useQuery(cacheKey, function () {
    invariant(contract, "contract must be defined");
    return contract.events.getAllEvents(options.queryFilter);
  }, {
    enabled: queryEnabled,
    // we do not need to re-fetch if we're subscribing
    refetchOnWindowFocus: !options.subscribe,
    refetchOnMount: true,
    refetchOnReconnect: true
  });
}
/**
 * Use this to query (and subscribe) to a specific event on a contract.
 *
 * @param contract - the contract instance of the contract to call a function on
 * @param options - options incldues the filters ({@link QueryAllEvents}) for the query as well as if you want to subscribe to real-time updates (default: true)
 * @returns a response object that includes the contract events
 * @beta
 */

function useContractEvents(contract, eventName) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    subscribe: true
  };
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryEnabled = !!contract && !!eventName;
  var queryClient = useQueryClient();
  var activeChainId = useActiveChainId();
  var cacheKey = useMemo(function () {
    return createCacheKeyWithNetwork(cacheKeys.contract.events.getAllEvents(contractAddress), activeChainId);
  }, [contractAddress]);
  useEffect(function () {
    // if we're not subscribing or query is not enabled yet we can early exit
    if (!options.subscribe || !queryEnabled || !contract || !eventName) {
      return;
    }

    var cleanupListener = contract.events.listenToAllEvents(function (contractEvent) {
      // insert new event to the front of the array (no duplicates, though)
      queryClient.setQueryData(cacheKey, function (oldData) {
        if (!oldData) {
          return [contractEvent];
        }

        var eventIsNotAlreadyInEventsList = oldData.findIndex(function (e) {
          return e.transaction.transactionHash === contractEvent.transaction.transactionHash && e.transaction.logIndex === contractEvent.transaction.logIndex;
        }) === -1;

        if (eventIsNotAlreadyInEventsList) {
          return [contractEvent].concat(_toConsumableArray(oldData));
        }

        return oldData;
      });
    }); // cleanup listener on unmount

    return cleanupListener;
  }, [queryEnabled, options.subscribe, cacheKey, eventName]);
  return useQuery(cacheKey, function () {
    invariant(contract, "contract must be defined");
    return contract.events.getEvents(eventName, options.queryFilter);
  }, {
    enabled: queryEnabled,
    // we do not need to re-fetch if we're subscribing
    refetchOnWindowFocus: !options.subscribe,
    refetchOnMount: true,
    refetchOnReconnect: true
  });
}

/**
 * @internal
 */

function convertResponseToNFTType(contract, metadata) {
  if (contract instanceof Erc721) {
    return _objectSpread2({
      type: "ERC721",
      supply: 1,
      owner: ""
    }, metadata);
  }

  return _objectSpread2({
    type: "ERC1155",
    supply: 0,
    owner: ""
  }, metadata);
}
/**
 * @internal
 */


function convertResponseToNFTTypeArray(contract, metadata) {
  return metadata.map(function (m) {
    return convertResponseToNFTType(contract, m);
  });
}
/** **********************/

/**     READ  HOOKS     **/

/** **********************/

/**
 * Use this to get an individual NFT token of your {@link NFTContract}.
 *
 * @example
 * ```javascript
 * const nftDrop = useNFTDrop(<ContractAddress>);
 * const { data: nft, isLoading, error } = useNFT(nftDrop, <tokenId>);
 * ```
 * @example
 * ```javascript
 * const { contract } = useContract(<ContractAddress>);
 * const { data: nft, isLoading, error } = useNFT(contract?.nft, <tokenId>);
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @param tokenId - the tokenId to look up
 * @returns a response object that includes the metadata for the given tokenId
 * @beta
 */


function useNFT(contract, tokenId) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.get(contractAddress, tokenId), /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            invariant(contract, "No Contract instance provided");
            invariant(contract.get, "Contract instance does not support get");
            _context.t0 = convertResponseToNFTType;
            _context.t1 = contract;
            _context.next = 6;
            return contract.get(BigNumber.from(tokenId || 0));

          case 6:
            _context.t2 = _context.sent;
            return _context.abrupt("return", (0, _context.t0)(_context.t1, _context.t2));

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })), {
    enabled: !!contract && tokenId !== undefined
  });
}
/**
 * Use this to get a list of NFT tokens of your {@link NFTContract}.
 *
 * @example
 * ```javascript
 * const nftDrop = useNFTDrop(<ContractAddress>);
 * const { data: nfts, isLoading, error } = useNFTs(nftDrop, { start: 0, count: 100 });
 * ```
 * @example
 * ```javascript
 * const { contract } = useContract(<ContractAddress>);
 * const { data: nfts, isLoading, error } = useNFTs(contract?.nft, { start: 0, count: 100 });
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @param queryParams - query params to pass to the query for the sake of pagination
 * @returns a response object that includes an array of NFTs
 * @beta
 */

function useNFTs(contract, queryParams) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.query.all(contractAddress, queryParams), /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var _contract$query;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            invariant(contract, "No Contract instance provided");
            invariant((_contract$query = contract.query) === null || _contract$query === void 0 ? void 0 : _contract$query.all, "Contract instance does not support query.all");
            _context2.t0 = convertResponseToNFTTypeArray;
            _context2.t1 = contract;
            _context2.next = 6;
            return contract.query.all(queryParams);

          case 6:
            _context2.t2 = _context2.sent;
            return _context2.abrupt("return", (0, _context2.t0)(_context2.t1, _context2.t2));

          case 8:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  })), {
    enabled: !!contract || !contractAddress,
    keepPreviousData: true
  });
}
/**
 * Use this to get a the total (minted) supply of your {@link NFTContract}.
 *
 *  * @example
 * ```javascript
 * const nftDrop = useNFTDrop(<ContractAddress>);
 * const { data: totalSupply, isLoading, error } = useNFTSupply(nftDrop);
 * ```
 * @example
 * ```javascript
 * const { contract } = useContract(<ContractAddress>);
 * const { data: totalSupply, isLoading, error } = useNFTSupply(contract?.nft);
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @returns a response object that incudes the total minted supply
 * @beta
 */

function useTotalCirculatingSupply() {
  for (var _len = arguments.length, _ref3 = new Array(_len), _key = 0; _key < _len; _key++) {
    _ref3[_key] = arguments[_key];
  }

  var contract = _ref3[0],
      tokenId = _ref3[1];
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.query.totalCirculatingSupply(contractAddress), function () {
    var _contract$query3;

    invariant(contract, "No Contract instance provided");

    if (contract instanceof Erc721) {
      var _contract$query2;

      invariant(contract === null || contract === void 0 ? void 0 : (_contract$query2 = contract.query) === null || _contract$query2 === void 0 ? void 0 : _contract$query2.totalCirculatingSupply, "Contract instance does not support query.totalCirculatingSupply");
      return contract.query.totalCirculatingSupply();
    }

    invariant((_contract$query3 = contract.query) === null || _contract$query3 === void 0 ? void 0 : _contract$query3.totalCirculatingSupply, "Contract instance does not support query.getTotalCount");
    invariant(tokenId, "No tokenId provided");
    return contract.query.totalCirculatingSupply(tokenId);
  }, {
    enabled: !!contract
  });
}
/**
 * Use this to get a the number of tokens in your {@link NFTContract}.
 *
 * @remarks The `total count` and `total supply` are the same for {@link ERC721} based contracts.
 * For {@link ERC1155} the `total count` is the number of NFTs that exist on the contract, **not** the sum of all supply of each token. (Since ERC1155 can have multiple owners per token.)
 *
 * @example
 * ```javascript
 * const nftDrop = useNFTDrop(<ContractAddress>);
 * const { data: totalCount, isLoading, error } = useTotalCount(nftDrop);
 * ```
 * @example
 * ```javascript
 * const { contract } = useContract(<ContractAddress>);
 * const { data: totalCount, isLoading, error } = useTotalCount(contract?.nft);
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @returns a response object that incudes the total number of tokens in the contract
 * @beta
 */

function useTotalCount(contract) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.query.totalCount(contractAddress), function () {
    var _contract$query5;

    invariant(contract, "No Contract instance provided");

    if (contract instanceof Erc721) {
      var _contract$query4;

      invariant(contract === null || contract === void 0 ? void 0 : (_contract$query4 = contract.query) === null || _contract$query4 === void 0 ? void 0 : _contract$query4.totalCirculatingSupply, "Contract instance does not support query.totalCirculatingSupply");
      return contract.query.totalCirculatingSupply();
    }

    invariant((_contract$query5 = contract.query) === null || _contract$query5 === void 0 ? void 0 : _contract$query5.totalCount, "Contract instance does not support query.totalCount");
    return contract.query.totalCount();
  }, {
    enabled: !!contract
  });
}
/**
 * Use this to get a the owned NFTs for a specific {@link NFTContract} and wallet address.
 *
 * @example
 * ```javascript
 * const nftDrop = useNFTDrop(<ContractAddress>);
 * const { data: ownedNFTs, isLoading, error } = useOwnedNFTs(nftDrop, <OwnerWalletAddress>);
 * ```
 * @example
 * ```javascript
 * const { contract } = useContract(<ContractAddress>);
 * const { data: ownedNFTs, isLoading, error } = useOwnedNFTs(contract?.nft, <OwnerWalletAddress>);
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @param ownerWalletAddress - the wallet adress to get owned tokens for
 * @returns a response object that includes the list of owned tokens
 * @beta
 */

function useOwnedNFTs(contract, ownerWalletAddress) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.query.owned.all(contractAddress, ownerWalletAddress), /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
    var _contract$query7;

    var _contract$query6, _contract$query6$owne;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            invariant(contract, "No Contract instance provided");

            if (!(contract instanceof Erc721)) {
              _context3.next = 9;
              break;
            }

            invariant((_contract$query6 = contract.query) === null || _contract$query6 === void 0 ? void 0 : (_contract$query6$owne = _contract$query6.owned) === null || _contract$query6$owne === void 0 ? void 0 : _contract$query6$owne.all, "Contract instance does not support query.owned.all");
            _context3.t0 = convertResponseToNFTTypeArray;
            _context3.t1 = contract;
            _context3.next = 7;
            return contract.query.owned.all(ownerWalletAddress);

          case 7:
            _context3.t2 = _context3.sent;
            return _context3.abrupt("return", (0, _context3.t0)(_context3.t1, _context3.t2));

          case 9:
            invariant((_contract$query7 = contract.query) === null || _contract$query7 === void 0 ? void 0 : _contract$query7.owned, "Contract instance does not support query.owned");
            _context3.t3 = convertResponseToNFTTypeArray;
            _context3.t4 = contract;
            _context3.next = 14;
            return contract.query.owned(ownerWalletAddress);

          case 14:
            _context3.t5 = _context3.sent;
            return _context3.abrupt("return", (0, _context3.t3)(_context3.t4, _context3.t5));

          case 16:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  })), {
    enabled: !!contract && !!ownerWalletAddress
  });
}
/**
 * Use this to get a the total balance of a {@link NFTContract} and wallet address.
 *
 *  @example
 * ```javascript
 * const nftDrop = useNFTDrop(<ContractAddress>);
 * const { data: ownerBalance, isLoading, error } = useNFTBalance(nftDrop, <OwnerWalletAddress>);
 * ```
 * @example
 * ```javascript
 * const { contract } = useContract(<ContractAddress>);
 * const { data: ownerBalance, isLoading, error } = useNFTBalance(contract?.nft, <OwnerWalletAddress>);
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @param ownerWalletAddress - the wallet adress to check the balance of
 * @returns a response object that includes the total balance of the owner
 * @beta
 */

function useNFTBalance() {
  for (var _len2 = arguments.length, _ref5 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    _ref5[_key2] = arguments[_key2];
  }

  var contract = _ref5[0],
      ownerWalletAddress = _ref5[1],
      tokenId = _ref5[2];
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.balanceOf(contractAddress, ownerWalletAddress, tokenId), function () {
    invariant(contract, "No Contract instance provided");
    invariant(contract.balanceOf, "Contract instance does not support balanceOf");
    invariant(ownerWalletAddress, "No owner wallet address provided");

    if (contract instanceof Erc1155) {
      invariant(tokenId, "No tokenId provided");
      return contract.balanceOf(ownerWalletAddress, tokenId);
    }

    return contract.balanceOf(ownerWalletAddress);
  }, {
    enabled: !!contract && !!ownerWalletAddress
  });
}
/** **********************/

/**     WRITE HOOKS     **/

/** **********************/

/**
 * Use this to mint a new NFT on your {@link NFTContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const nftDrop = useNFTDrop(<ContractAddress>);
 *   const {
 *     mutate: mintNft,
 *     isLoading,
 *     error,
 *   } = useMintNFT(nftDrop);
 *
 *   if (error) {
 *     console.error("failed to mint nft", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => mintNft({ name: "My awesome NFT!", to: "0x..." })}
 *     >
 *       Mint!
 *     </button>
 *   );
 * };
 * ```
 * @example
 * ```jsx
 * const Component = () => {
 *   const { contract } = useContract(<ContractAddress>);
 *   const {
 *     mutate: mintNft,
 *     isLoading,
 *     error,
 *   } = useMintNFT(contract?.nft);
 *
 *   if (error) {
 *     console.error("failed to mint nft", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => mintNft({ name: "My awesome NFT!", to: "0x..." })}
 *     >
 *       Mint!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @returns a mutation object that can be used to mint a new NFT token to the connected wallet
 * @beta
 */

function useMintNFT(contract) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  return useMutation( /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(data) {
      var _contract$mint;

      var to, metadata, supply;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              invariant(data.to, 'No "to" address provided');
              invariant(contract === null || contract === void 0 ? void 0 : (_contract$mint = contract.mint) === null || _contract$mint === void 0 ? void 0 : _contract$mint.to, "contract does not support mint.to");

              if (!(contract instanceof Erc1155)) {
                _context4.next = 8;
                break;
              }

              invariant("supply" in data, "supply not provided");
              to = data.to, metadata = data.metadata, supply = data.supply;
              _context4.next = 7;
              return contract.mint.to(to, {
                metadata: metadata,
                supply: BigNumber.from(supply || 1)
              });

            case 7:
              return _context4.abrupt("return", _context4.sent);

            case 8:
              _context4.next = 10;
              return contract.mint.to(data.to, data.metadata);

            case 10:
              return _context4.abrupt("return", _context4.sent);

            case 11:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function (_x) {
      return _ref6.apply(this, arguments);
    };
  }(), {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}
/**
 * Use this to mint a new NFT on your {@link NFTContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const nftDrop = useNFTDrop(<ContractAddress>);
 *   const {
 *     mutate: mintNftSupply,
 *     isLoading,
 *     error,
 *   } = useMintNFTSupply(nftDrop);
 *
 *   if (error) {
 *     console.error("failed to mint additional supply", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => mintNftSupply({ tokenId: 0, additionalSupply: 100, to: "0x..."})}
 *     >
 *       Mint Additional Supply!
 *     </button>
 *   );
 * };
 * ```
 * @example
 * ```jsx
 * const Component = () => {
 *   const { contract } = useContract(<ContractAddress>);
 *   const {
 *     mutate: mintNftSupply,
 *     isLoading,
 *     error,
 *   } = useMintNFTSupply(contract?.nft);
 *
 *   if (error) {
 *     console.error("failed to mint additional supply", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => mintNftSupply({ tokenId: 0, additionalSupply: 100, to: "0x..."})}
 *     >
 *       Mint Additional Supply!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link Erc1155}
 * @returns a mutation object that can be used to mint a more supply of a token id to the provided wallet
 * @beta
 */

function useMintNFTSupply(contract) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  return useMutation( /*#__PURE__*/function () {
    var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(data) {
      var _contract$mint2;

      var to, tokenId, additionalSupply;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              invariant(data.to, 'No "to" address provided');
              invariant(contract === null || contract === void 0 ? void 0 : (_contract$mint2 = contract.mint) === null || _contract$mint2 === void 0 ? void 0 : _contract$mint2.additionalSupplyTo, "contract does not support mint.additionalSupplyTo");
              invariant("tokenId" in data, "tokenId not provided");
              invariant("additionalSupply" in data, "additionalSupply not provided");
              to = data.to, tokenId = data.tokenId, additionalSupply = data.additionalSupply;
              _context5.next = 7;
              return contract.mint.additionalSupplyTo(to, tokenId, additionalSupply);

            case 7:
              return _context5.abrupt("return", _context5.sent);

            case 8:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    return function (_x2) {
      return _ref7.apply(this, arguments);
    };
  }(), {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}
/**
 * Use this to transfer tokens on your {@link NFTContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const nftDrop = useNFTDrop(<ContractAddress>);
 *   const {
 *     mutate: transferNFT,
 *     isLoading,
 *     error,
 *   } = useTransferNFT(nftDrop);
 *
 *   if (error) {
 *     console.error("failed to transfer nft", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => transferNFT({ to: "0x...", tokenId: 2 })}
 *     >
 *       Transfer NFT!
 *     </button>
 *   );
 * };
 * ```
 * @example
 * ```jsx
 * const Component = () => {
 *   const { contract } = useContract(<ContractAddress>);
 *   const {
 *     mutate: transferNFT,
 *     isLoading,
 *     error,
 *   } = useTransferNFT(contract?.nft);
 *
 *   if (error) {
 *     console.error("failed to transfer nft", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => transferNFT({ to: "0x...", tokenId: 2 })}
 *     >
 *       Transfer
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @returns a mutation object that can be used to transfer NFTs
 * @beta
 */

function useTransferNFT(contract) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  return useMutation(function (data) {
    invariant(contract === null || contract === void 0 ? void 0 : contract.transfer, "contract does not support transfer");

    if (contract instanceof Erc1155) {
      invariant("amount" in data, "amount not provided");
      return contract.transfer(data.to, data.tokenId, data.amount);
    }

    return contract.transfer(data.to, data.tokenId);
  }, {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}
/**
 * Use this to transfer tokens on your {@link Erc1155}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const editionDrop = useEditionDrop(<ContractAddress>);
 *   const {
 *     mutate: airdropNFT,
 *     isLoading,
 *     error,
 *   } = useAirdropNFT(editionDrop);
 *
 *   if (error) {
 *     console.error("failed to transfer batch NFTs", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => airdropNFT({
 *          tokenId: 2,
 *          addresses: [{ address: "0x...", quantity: 2 }, { address: "0x...", quantity: 4 } }]
 *       )}
 *     >
 *       Airdrop NFT
 *     </button>
 * };
 * ```
 * @example
 * ```jsx
 * const Component = () => {
 *   const { contract } = useContract(<ContractAddress>);
 *   const {
 *     mutate: airdropNFT,
 *     isLoading,
 *     error,
 *   } = useAirdropNFT(contract?.nft);
 *
 *   if (error) {
 *     console.error("failed to transfer batch NFTs", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => airdropNFT({
 *          tokenId: 2,
 *          addresses: [{ address: "0x...", quantity: 2 }, { address: "0x...", quantity: 4 } }]
 *       )}
 *     >
 *       Airdrop NFT
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link Erc1155}
 * @returns a mutation object that can be used to transfer batch NFTs
 * @beta
 */

function useAirdropNFT(contract) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  return useMutation(function (_ref8) {
    var tokenId = _ref8.tokenId,
        addresses = _ref8.addresses;
    invariant(contract === null || contract === void 0 ? void 0 : contract.airdrop, "contract does not support airdrop");
    return contract.airdrop(tokenId, addresses);
  }, {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}
/** **********************/

/**     WRITE HOOKS     **/

/** **********************/

/**
 * Use this to burn an NFT on your {@link NFTContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const nftDrop = useNFTDrop(<ContractAddress>);
 *   const {
 *     mutate: burnNft,
 *     isLoading,
 *     error,
 *   } = useBurnNFT(nftDrop);
 *
 *   if (error) {
 *     console.error("failed to burn nft", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => burnNft({ tokenId: 0 })}
 *     >
 *       Burn!
 *     </button>
 *   );
 * };
 * ```
 * @example
 * ```jsx
 * const Component = () => {
 *   const { contract } = useContract(<ContractAddress>);
 *   const {
 *     mutate: burnNft,
 *     isLoading,
 *     error,
 *   } = useBurnNFT(contract?.nft);
 *
 *   if (error) {
 *     console.error("failed to burn nft", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => burnNft({ tokenId: 0 })}
 *     >
 *       Burn!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @returns a mutation object that can be used to burn an NFT token from the connected wallet
 * @beta
 */

function useBurnNFT(contract) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  return useMutation( /*#__PURE__*/function () {
    var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(data) {
      var _tokenId, amount, tokenId;

      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              invariant(data.tokenId, "No tokenId provided");
              invariant(contract === null || contract === void 0 ? void 0 : contract.burn, "contract does not support burn");

              if (!(contract instanceof Erc1155)) {
                _context6.next = 8;
                break;
              }

              invariant("amount" in data, "amount not provided");
              _tokenId = data.tokenId, amount = data.amount;
              _context6.next = 7;
              return contract.burn.tokens(_tokenId, amount);

            case 7:
              return _context6.abrupt("return", _context6.sent);

            case 8:
              tokenId = data.tokenId;
              _context6.next = 11;
              return contract.burn.token(tokenId);

            case 11:
              return _context6.abrupt("return", _context6.sent);

            case 12:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    return function (_x3) {
      return _ref9.apply(this, arguments);
    };
  }(), {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}

/** **********************/

/**       READ HOOKS    **/

/** **********************/

/**
 * Use this to get a list of *unclaimed* NFT tokens of your ERC721 Drop contract.
 *
 * @example
 * ```javascript
 * const { data: unclaimedNfts, isLoading, error } = useUnclaimedNFTs(<YourERC721DropContractInstance>, { start: 0, count: 100 });
 * ```
 *
 * @param contract - an instance of a contract that extends the Erc721 spec (nft drop, custom contract that follows the Erc721 & drop spec)
 * @param queryParams - query params to pass to the query for the sake of pagination
 * @returns a response object that includes an array of NFTs that are unclaimed
 * @beta
 */

function useUnclaimedNFTs(contract, queryParams) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.drop.getAllUnclaimed(contractAddress, queryParams), function () {
    invariant(contract, "No Contract instance provided");
    invariant(contract.getAllUnclaimed, "Contract instance does not support getAllUnclaimed");
    return contract.getAllUnclaimed(queryParams);
  }, {
    enabled: !!contract
  });
}
/**
 * Use this to get a list of *claimed* (minted) NFT tokens of your ERC721 Drop contract.
 *
 * @remarks Equivalent to using {@link useNFTs}.
 *
 * @example
 * ```javascript
 * const { data: claimedNFTs, isLoading, error } = useClaimedNFTs(<YourERC721DropContractInstance>, { start: 0, count: 100 });
 * ```
 *
 * @param contract - an instance of a {@link DropContract}
 * @param queryParams - query params to pass to the query for the sake of pagination
 * @returns a response object that includes an array of NFTs that are claimed
 * @beta
 */

function useClaimedNFTs(contract, queryParams) {
  return useNFTs(contract, queryParams);
}
/**
 *
 * @param contract - an instance of a {@link NFTDrop}
 * @returns a response object that includes the number of NFTs that are unclaimed
 */

function useUnclaimedNFTSupply(contract) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.drop.totalUnclaimedSupply(contractAddress), function () {
    invariant(contract, "No Contract instance provided");
    invariant(contract.totalUnclaimedSupply, "Contract instance does not support totalUnclaimedSupply");
    return contract.totalUnclaimedSupply();
  }, {
    enabled: !!contract
  });
}
/**
 *
 * @param contract - an instance of a {@link DropContract}
 * @returns a response object that includes the number of NFTs that are claimed
 */

function useClaimedNFTSupply(contract) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.drop.totalClaimedSupply(contractAddress), function () {
    invariant(contract, "No Contract instance provided");

    if (contract instanceof Erc1155) {
      return contract.getTotalCount();
    }

    invariant(contract.totalClaimedSupply, "Contract instance does not support totalClaimedSupply");
    return contract.totalClaimedSupply();
  }, {
    enabled: !!contract
  });
}
/**
 *
 * @param contract - an instance of a {@link NFTContract}
 * @returns a response object that gets the batches to still be revealed
 */

function useBatchesToReveal(contract) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.nft.drop.revealer.getBatchesToReveal(contractAddress), function () {
    var _contract$drop, _contract$drop$reveal;

    invariant(contract, "No Contract instance provided");
    invariant((_contract$drop = contract.drop) === null || _contract$drop === void 0 ? void 0 : (_contract$drop$reveal = _contract$drop.revealer) === null || _contract$drop$reveal === void 0 ? void 0 : _contract$drop$reveal.getBatchesToReveal, "Contract instance does not support drop.revealer.getBatchesToReveal");
    return contract.drop.revealer.getBatchesToReveal();
  }, {
    enabled: !!contract
  });
}
/** **********************/

/**     WRITE HOOKS     **/

/** **********************/

/**
 * Use this to claim a NFT on your {@link DropContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: claimNft,
 *     isLoading,
 *     error,
 *   } = useClaimNFT(DropContract);
 *
 *   if (error) {
 *     console.error("failed to claim nft", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => claimNft({ to: "0x...", quantity: 1 })}
 *     >
 *       Claim NFT!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link DropContract}
 * @returns a mutation object that can be used to claim a NFT to the wallet specificed in the params
 * @beta
 */

function useClaimNFT(contract) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  return useMutation( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(data) {
      var to, tokenId, quantity;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              invariant(data.to, 'No "to" address provided');
              invariant(contract === null || contract === void 0 ? void 0 : contract.claimTo, "contract does not support claimTo");

              if (!(contract instanceof Erc1155)) {
                _context.next = 8;
                break;
              }

              invariant("tokenId" in data, "tokenId not provided");
              to = data.to, tokenId = data.tokenId, quantity = data.quantity;
              _context.next = 7;
              return contract.claimTo(to, tokenId, quantity, data.checkERC20Allowance);

            case 7:
              return _context.abrupt("return", _context.sent);

            case 8:
              _context.next = 10;
              return contract.claimTo(data.to, data.quantity, data.checkERC20Allowance);

            case 10:
              return _context.abrupt("return", _context.sent);

            case 11:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}
/**
 * Use this to lazy mint a batch of NFTs on your {@link DropContract}
 *
 * @param contract - an instance of a {@link NFTContract} with the drop extension
 * @param onProgress - an optional callback that will be called with the progress of the upload
 * @returns a mutation object that can be used to lazy mint a batch of NFTs
 * @beta
 */

function useLazyMint(contract, onProgress) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  return useMutation( /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(data) {
      var _contract$drop2;

      var options;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              invariant(contract === null || contract === void 0 ? void 0 : (_contract$drop2 = contract.drop) === null || _contract$drop2 === void 0 ? void 0 : _contract$drop2.lazyMint, "contract does not support drop.lazyMint");

              if (onProgress) {
                options = {
                  onProgress: onProgress
                };
              }

              _context2.next = 4;
              return contract.drop.lazyMint(data.metadatas, options);

            case 4:
              return _context2.abrupt("return", _context2.sent);

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x2) {
      return _ref2.apply(this, arguments);
    };
  }(), {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}
/**
 * Use this to lazy mint a batch of delayed reveal NFTs on your {@link DropContract}
 *
 * @param contract - an instance of a {@link NFTContract} with the drop extension
 * @param onProgress - an optional callback that will be called with the progress of the upload
 * @returns a mutation object that can be used to lazy mint a batch of NFTs
 * @beta
 */

function useDelayedRevealLazyMint(contract, onProgress) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  return useMutation( /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(data) {
      var _contract$drop3, _contract$drop3$revea;

      var options;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              invariant(contract === null || contract === void 0 ? void 0 : (_contract$drop3 = contract.drop) === null || _contract$drop3 === void 0 ? void 0 : (_contract$drop3$revea = _contract$drop3.revealer) === null || _contract$drop3$revea === void 0 ? void 0 : _contract$drop3$revea.createDelayedRevealBatch, "contract does not support drop.revealer.createDelayedRevealBatch");

              if (onProgress) {
                options = {
                  onProgress: onProgress
                };
              }

              _context3.next = 4;
              return contract.drop.revealer.createDelayedRevealBatch(data.placeholder, data.metadatas, data.password, options);

            case 4:
              return _context3.abrupt("return", _context3.sent);

            case 5:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function (_x3) {
      return _ref3.apply(this, arguments);
    };
  }(), {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}
/**
 * Use this to reveal a batch of delayed reveal NFTs on your {@link DropContract}
 *
 * @param contract - an instance of a {@link NFTContract} with the drop extension
 * @returns a mutation object that can be used to reveal a batch of delayed reveal NFTs
 * @beta
 */

function useRevealLazyMint(contract) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  return useMutation( /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(data) {
      var _contract$drop4, _contract$drop4$revea;

      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              invariant(contract === null || contract === void 0 ? void 0 : (_contract$drop4 = contract.drop) === null || _contract$drop4 === void 0 ? void 0 : (_contract$drop4$revea = _contract$drop4.revealer) === null || _contract$drop4$revea === void 0 ? void 0 : _contract$drop4$revea.reveal, "contract does not support drop.revealer.reveal");
              _context4.next = 3;
              return contract.drop.revealer.reveal(data.batchId, data.password);

            case 3:
              return _context4.abrupt("return", _context4.sent);

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function (_x4) {
      return _ref4.apply(this, arguments);
    };
  }(), {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}

/** **********************/

/**     READ  HOOKS     **/

/** **********************/

/**
 * Use this to get a specific listing from the marketplace.
 *
 * @example
 * ```javascript
 * const { data: listing, isLoading, error } = useListing(<YourMarketplaceContractInstance>, <listingId>);
 * ```
 *
 * @param contract - an instance of a marketplace contract
 * @param listingId - the listing id to check
 * @returns a response object that includes an array of listings
 * @beta
 */

function useListing(contract, listingId) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.getListing(contractAddress, listingId), function () {
    invariant(contract, "No Contract instance provided");
    return contract.getListing(BigNumber.from(listingId || 0));
  }, {
    enabled: !!contract || !contractAddress,
    keepPreviousData: true
  });
}
/**
 * Use this to get a list all listings from your marketplace contract.
 *
 * @example
 * ```javascript
 * const { data: listings, isLoading, error } = useListings(<YourMarketplaceContractInstance>, { start: 0, count: 100 });
 * ```
 *
 * @param contract - an instance of a marketplace contract
 * @param filter - filter to pass to the query for the sake of pagination & filtering
 * @returns a response object that includes an array of listings
 * @beta
 */

function useListings(contract, filter) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.getAllListings(contractAddress, filter), function () {
    invariant(contract, "No Contract instance provided");
    return contract.getAllListings(filter);
  }, {
    enabled: !!contract || !contractAddress,
    keepPreviousData: true
  });
}
/**
 * Use this to get a list active listings from your marketplace contract.
 *
 * @example
 * ```javascript
 * const { data: listings, isLoading, error } = useActiveListings(<YourMarketplaceContractInstance>, { seller: "0x...", tokenContract: "0x...", tokenId: 1, start: 0, count: 100 });
 * ```
 *
 * @param contract - an instance of a marketplace contract
 * @param filter - filter to pass to the query for the sake of pagination & filtering
 * @returns a response object that includes an array of listings
 * @beta
 */

function useActiveListings(contract, filter) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.getActiveListings(contractAddress, filter), function () {
    invariant(contract, "No Contract instance provided");
    return contract.getActiveListings(filter);
  }, {
    enabled: !!contract || !contractAddress,
    keepPreviousData: true
  });
}
/**
 * Use this to get a the winning bid for an auction listing from your marketplace contract.
 *
 * @example
 * ```javascript
 * const { data: winningBid, isLoading, error } = useWinningBid(<YourMarketplaceContractInstance>, <listingId>);
 * ```
 *
 * @param contract - an instance of a marketplace contract
 * @param listingId - the listing id to check
 * @returns a response object that includes the {@link Offer} that is winning the auction
 * @beta
 */

function useWinningBid(contract, listingId) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.auction.getWinningBid(contractAddress, listingId), function () {
    invariant(contract, "No Contract instance provided");
    return contract.auction.getWinningBid(BigNumber.from(listingId || 0));
  }, {
    enabled: !!contract && listingId !== undefined
  });
}
/**
 * Use this to get the winner of an auction listing from your marketplace contract.
 *
 * @example
 * ```javascript
 * const { data: auctionWinner, isLoading, error } = useAuctionWinner(<YourMarketplaceContractInstance>, <listingId>);
 * ```
 *
 * @param contract - an instance of a marketplace contract
 * @param listingId - the listing id to check
 * @returns a response object that includes the address of the winner of the auction or undefined if there is no winner yet
 * @beta
 */

function useAuctionWinner(contract, listingId) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.auction.getWinner(contractAddress, listingId), /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var winner, _message;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            invariant(contract, "No Contract instance provided");
            _context.prev = 1;
            _context.next = 4;
            return contract.auction.getWinner(BigNumber.from(listingId || 0));

          case 4:
            winner = _context.sent;
            _context.next = 11;
            break;

          case 7:
            _context.prev = 7;
            _context.t0 = _context["catch"](1);

            if (_context.t0 !== null && _context.t0 !== void 0 && (_message = _context.t0.message) !== null && _message !== void 0 && _message.includes("Could not find auction")) {
              _context.next = 11;
              break;
            }

            throw _context.t0;

          case 11:
            return _context.abrupt("return", winner);

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1, 7]]);
  })), {
    enabled: !!contract && listingId !== undefined
  });
}
/**
 * Use this to get the buffer in basis points between offers from your marketplace contract.
 *
 * @example
 * ```javascript
 * const { data: auctionWinner, isLoading, error } = useBidBuffer(<YourMarketplaceContractInstance>);
 * ```
 *
 * @param contract - an instance of a marketplace contract

 * @returns a response object that includes an array of listings
 * @beta
 */

function useBidBuffer(contract) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.marketplace.getBidBufferBps(contractAddress), function () {
    invariant(contract, "No Contract instance provided");
    return contract.getBidBufferBps();
  }, {
    enabled: !!contract
  });
}
/** **********************/

/**     WRITE HOOKS     **/

/** **********************/

/**
 * Use this to create a new Direct Listing on your marketplace contract.
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: createDirectListing,
 *     isLoading,
 *     error,
 *   } = useCreateDirectListing(">>YourMarketplaceContractInstance<<");
 *
 *   if (error) {
 *     console.error("failed to create direct listing", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => createDirectListing(directListingData)}
 *     >
 *       Create Direct Listing!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a Marketplace contract
 * @returns a mutation object that can be used to create a new direct listing
 * @beta
 */

function useCreateDirectListing(contract) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  var walletAddress = useAddress();
  return useMutation( /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(data) {
      var _contract$direct;

      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              invariant(walletAddress, "no wallet connected, cannot create listing");
              invariant(contract === null || contract === void 0 ? void 0 : (_contract$direct = contract.direct) === null || _contract$direct === void 0 ? void 0 : _contract$direct.createListing, "contract does not support direct.createListing");
              _context2.next = 4;
              return contract.direct.createListing(data);

            case 4:
              return _context2.abrupt("return", _context2.sent);

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }(), {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}
/**
 * Use this to create a new Auction Listing on your marketplace contract.
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: createAuctionListing,
 *     isLoading,
 *     error,
 *   } = useCreateAuctionListing(">>YourMarketplaceContractInstance<<");
 *
 *   if (error) {
 *     console.error("failed to create auction listing", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => createAuctionListing(auctionListingData)}
 *     >
 *       Create Auction Listing!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a Marketplace contract
 * @returns a mutation object that can be used to create a new auction listing
 * @beta
 */

function useCreateAuctionListing(contract) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  var walletAddress = useAddress();
  return useMutation( /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(data) {
      var _contract$direct2;

      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              invariant(walletAddress, "no wallet connected, cannot create listing");
              invariant(contract === null || contract === void 0 ? void 0 : (_contract$direct2 = contract.direct) === null || _contract$direct2 === void 0 ? void 0 : _contract$direct2.createListing, "contract does not support auction.createListing");
              _context3.next = 4;
              return contract.auction.createListing(data);

            case 4:
              return _context3.abrupt("return", _context3.sent);

            case 5:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function (_x2) {
      return _ref3.apply(this, arguments);
    };
  }(), {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}
/**
 * Use this to place a bid on an auction listing from your marketplace contract.
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: makeBid,
 *     isLoading,
 *     error,
 *   } = useMakeBid(">>YourMarketplaceContractInstance<<");
 *
 *   if (error) {
 *     console.error("failed to make a bid", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => makeBid({ listingId: 1, bid: 2 })}
 *     >
 *       Bid!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a Marketplace contract
 * @returns a mutation object that can be used to make a bid on an auction listing
 * @beta
 */

function useMakeBid(contract) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  var walletAddress = useAddress();
  return useMutation( /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(data) {
      var _contract$auction;

      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              invariant(walletAddress, "no wallet connected, cannot make bid");
              invariant(contract === null || contract === void 0 ? void 0 : (_contract$auction = contract.auction) === null || _contract$auction === void 0 ? void 0 : _contract$auction.makeBid, "contract does not support auction.makeBid");
              _context4.next = 4;
              return contract.auction.makeBid(data.listingId, data.bid);

            case 4:
              return _context4.abrupt("return", _context4.sent);

            case 5:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function (_x3) {
      return _ref4.apply(this, arguments);
    };
  }(), {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}
/**
 * Use this to buy out an auction listing from your marketplace contract.
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: buyNow,
 *     isLoading,
 *     error,
 *   } = useBuyNow(">>YourMarketplaceContractInstance<<");
 *
 *   if (error) {
 *     console.error("failed to buyout listing", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => buyNow({listingId: 1, type: ListingType.Auction})}
 *     >
 *       Buy listing!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a Marketplace contract
 * @returns a mutation object that can be used to buy out an auction listing
 * @beta
 */

function useBuyNow(contract) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  var walletAddress = useAddress();
  return useMutation( /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(data) {
      var _contract$auction2;

      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              invariant(walletAddress, "no wallet connected, cannot make bid");

              if (!(data.type === ListingType.Direct)) {
                _context5.next = 6;
                break;
              }

              invariant(contract === null || contract === void 0 ? void 0 : contract.direct.buyoutListing, "contract does not support direct.buyoutListing");
              _context5.next = 5;
              return contract.direct.buyoutListing(data.id, data.buyAmount, data.buyForWallet);

            case 5:
              return _context5.abrupt("return", _context5.sent);

            case 6:
              invariant(contract === null || contract === void 0 ? void 0 : (_contract$auction2 = contract.auction) === null || _contract$auction2 === void 0 ? void 0 : _contract$auction2.buyoutListing, "contract does not support auction.buyoutListing");
              _context5.next = 9;
              return contract.auction.buyoutListing(data.id);

            case 9:
              return _context5.abrupt("return", _context5.sent);

            case 10:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    return function (_x4) {
      return _ref5.apply(this, arguments);
    };
  }(), {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}

/** **********************/

/**     READ  HOOKS     **/

/** **********************/

/**
 * Use this to get a the total supply of your {@link Erc20} contract.
 *
 * @example
 * ```javascript
 * const { data: totalSupply, isLoading, error } = useTokenSupply(<YourTokenContractInstance>);
 * ```
 *
 * @param contract - an instance of a Token contract.
 * @returns a response object that incudes the total minted supply
 * @beta
 */

function useTokenSupply(contract) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.token.totalSupply(contractAddress), function () {
    invariant(contract, "No Contract instance provided");
    return contract.totalSupply();
  }, {
    enabled: !!contract || !!contractAddress
  });
}
/**
 * Use this to get the balance of your {@link Erc20} contract for a given address.
 *
 * @example
 * ```javascript
 * const { data: balance, isLoading, error } = useTokenBalance(<YourTokenContractInstance>);
 * ```
 *
 * @param contract - an instance of a Token contract.
 * @returns a response object that includes the balance of the address
 * @beta
 */

function useTokenBalance(contract, walletAddress) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.contract.token.balanceOf(contractAddress, walletAddress), /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            invariant(contract, "No Contract instance provided");
            invariant(walletAddress, "No address provided");
            _context.next = 4;
            return contract.balanceOf(walletAddress);

          case 4:
            return _context.abrupt("return", _context.sent);

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })), {
    enabled: !!walletAddress && !!contract
  });
}
/** **********************/

/**     WRITE HOOKS     **/

/** **********************/

/**
 * Use this to mint new tokens on your {@link Erc20} contract
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: mintTokens,
 *     isLoading,
 *     error,
 *   } = useMintToken(">>YourERC20ContractInstance<<");
 *
 *   if (error) {
 *     console.error("failed to mint tokens", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => mintTokens({ to: "0x...", amount: 1000 })}
 *     >
 *       Mint!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a contract that extends the ERC20 spec (token, token drop, custom contract that follows the ERC20 spec)
 * @returns a mutation object that can be used to mint new tokens to the connected wallet
 * @beta
 */

function useMintToken(contract) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  return useMutation(function (data) {
    var _contract$mint;

    var to = data.to,
        amount = data.amount;
    invariant(contract === null || contract === void 0 ? void 0 : (_contract$mint = contract.mint) === null || _contract$mint === void 0 ? void 0 : _contract$mint.to, "contract does not support mint.to");
    return contract.mint.to(to, amount);
  }, {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}
/**
 * Use this to claim tokens on your {@link TokenDrop}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: claimTokens,
 *     isLoading,
 *     error,
 *   } = useClaimToken(TokenDropContract);
 *
 *   if (error) {
 *     console.error("failed to claim tokens", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => claimTokens({ to: "0x...", amount: 100 })}
 *     >
 *       Claim Tokens!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link TokenDrop}
 * @returns a mutation object that can be used to tokens to the wallet specificed in the params
 * @beta
 */

function useClaimToken(contract) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  return useMutation( /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(data) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              invariant(data.to, 'No "to" address provided');
              invariant(contract === null || contract === void 0 ? void 0 : contract.claimTo, "contract does not support claimTo");
              _context2.next = 4;
              return contract.claimTo(data.to, data.amount, data.checkERC20Allowance);

            case 4:
              return _context2.abrupt("return", _context2.sent);

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }(), {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}
/**
 * Use this to transfer tokens on your {@link Erc20} contract
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: transferTokens,
 *     isLoading,
 *     error,
 *   } = useTransferToken(">>YourERC20ContractInstance<<");
 *
 *   if (error) {
 *     console.error("failed to transfer tokens", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => transferTokens({ to: "0x...", amount: 1000 })}
 *     >
 *       Transfer
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a contract that extends the ERC20 spec (token, token drop, custom contract that follows the ERC20 spec)
 * @returns a mutation object that can be used to transfer tokens
 * @beta
 */

function useTransferToken(contract) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  return useMutation(function (data) {
    var to = data.to,
        amount = data.amount;
    invariant(contract === null || contract === void 0 ? void 0 : contract.transfer, "contract does not support transfer");
    return contract.transfer(to, amount);
  }, {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}
/**
 * Use this to transfer batch tokens on your {@link Erc20} contract
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: transferBatchTokens,
 *     isLoading,
 *     error,
 *   } = useTransferToken(">>YourERC20ContractInstance<<");
 *
 *   if (error) {
 *     console.error("failed to transfer batch tokens", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => transferBatchTokens([{ to: "0x...", amount: 1000 }, { to: "0x...", amount: 2000 }])}
 *     >
 *       Transfer Batch
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a contract that extends the ERC20 spec (token, token drop, custom contract that follows the ERC20 spec)
 * @returns a mutation object that can be used to transfer batch tokens
 * @beta
 */

function useTransferBatchToken(contract) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  return useMutation(function (data) {
    invariant(contract === null || contract === void 0 ? void 0 : contract.transferBatch, "contract does not support transferBatch");
    var convertedData = data.map(function (token) {
      return {
        toAddress: token.to,
        amount: token.amount
      };
    });
    return contract.transferBatch(convertedData);
  }, {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}
/**
 * Use this to burn tokens on your {@link Erc20} contract
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: burnTokens,
 *     isLoading,
 *     error,
 *   } = useBurnToken(">>YourERC20ContractInstance<<");
 *
 *   if (error) {
 *     console.error("failed to burn tokens", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => burnTokens({ amount: 1000 })}
 *     >
 *       Burn!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a contract that extends the ERC20 spec (token, token drop, custom contract that follows the ERC20 spec)
 * @returns a mutation object that can be used to burn tokens from the connected wallet
 * @beta
 */

function useBurnToken(contract) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  return useMutation(function (data) {
    var amount = data.amount;
    invariant(contract === null || contract === void 0 ? void 0 : contract.burn, "contract does not support burn");
    return contract.burn.tokens(amount);
  }, {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}

/** **********************/

/**     READ  HOOKS     **/

/** **********************/

/**
 * Use this to get the active claim conditon for ERC20, ERC721 or ERC1155 based contracts. They need to extend the `claimCondition` extension for this hook to work.
 *
 * @example
 * ```javascript
 * const { data: activeClaimCondition, isLoading, error } = useActiveClaimCondition(<YourERC20ContractInstance>);
 * ```
 * @example
 * ```javascript
 * const { data: activeClaimCondition, isLoading, error } = useActiveClaimCondition(<YourERC721ContractInstance>);
 * ```
 * @example
 * ```javascript
 * const { data: activeClaimCondition, isLoading, error } = useActiveClaimCondition(<YourERC1155ContractInstance>, <tokenId>);
 * ```
 *
 * @param contract - an instance of a contract that extends the ERC721 or ERC1155 spec and implements the `claimConditions` extension.
 * @param tokenId - the id of the token to fetch the claim conditions for (if the contract is an ERC1155 contract)
 * @returns a response object with the currently active claim condition
 *
 * @beta
 */
function useActiveClaimCondition() {
  for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
    _ref[_key] = arguments[_key];
  }

  var contract = _ref[0],
      tokenId = _ref[1];
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.claimConditions.getActive(contractAddress, tokenId), function () {
    var _contract$drop, _contract$drop$claim, _contract$drop$claim$, _contract$drop3, _contract$drop3$claim, _contract$drop3$claim2;

    invariant(contract, "No Contract instance provided");
    invariant(contract === null || contract === void 0 ? void 0 : (_contract$drop = contract.drop) === null || _contract$drop === void 0 ? void 0 : (_contract$drop$claim = _contract$drop.claim) === null || _contract$drop$claim === void 0 ? void 0 : (_contract$drop$claim$ = _contract$drop$claim.conditions) === null || _contract$drop$claim$ === void 0 ? void 0 : _contract$drop$claim$.getActive, "Contract instance does not support contract?.drop?.claim?.conditions.getActive");

    if (contract instanceof Erc1155) {
      var _contract$drop2, _contract$drop2$claim, _contract$drop2$claim2;

      invariant(tokenId, "tokenId is required for ERC1155 claim conditions");
      return contract === null || contract === void 0 ? void 0 : (_contract$drop2 = contract.drop) === null || _contract$drop2 === void 0 ? void 0 : (_contract$drop2$claim = _contract$drop2.claim) === null || _contract$drop2$claim === void 0 ? void 0 : (_contract$drop2$claim2 = _contract$drop2$claim.conditions) === null || _contract$drop2$claim2 === void 0 ? void 0 : _contract$drop2$claim2.getActive(tokenId);
    }

    return contract === null || contract === void 0 ? void 0 : (_contract$drop3 = contract.drop) === null || _contract$drop3 === void 0 ? void 0 : (_contract$drop3$claim = _contract$drop3.claim) === null || _contract$drop3$claim === void 0 ? void 0 : (_contract$drop3$claim2 = _contract$drop3$claim.conditions) === null || _contract$drop3$claim2 === void 0 ? void 0 : _contract$drop3$claim2.getActive();
  }, {
    // Checks that happen here:
    // 1. if the contract is based on ERC1155 contract => tokenId cannot be `undefined`
    // 2. if the contract is NOT based on ERC1155 => contract has to still be provided
    enabled: contract instanceof Erc1155 ? tokenId !== undefined : !!contract
  });
}
/**
 * Use this to get all claim conditons for ERC20, ERC721 or ERC1155 based contracts. They need to extend the `claimCondition` extension for this hook to work.
 *
 * @example
 * ```javascript
 * const { data: claimConditions, isLoading, error } = useClaimConditions(<YourERC20ContractInstance>);
 * ```
 * @example
 * ```javascript
 * const { data: claimConditions, isLoading, error } = useClaimConditions(<YourERC721ContractInstance>);
 * ```
 * @example
 * ```javascript
 * const { data: claimConditions, isLoading, error } = useClaimConditions(<YourERC1155ContractInstance>, <tokenId>);
 * ```
 *
 * @param contract - an instance of a contract that extends the ERC721 or ERC1155 spec and implements the `claimConditions` extension.
 * @param tokenId - the id of the token to fetch the claim conditions for (if the contract is an ERC1155 contract)
 * @returns a response object with the list of claim conditions
 *
 * @beta
 */

function useClaimConditions() {
  for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    _ref2[_key2] = arguments[_key2];
  }

  var contract = _ref2[0],
      tokenId = _ref2[1];
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.claimConditions.getAll(contractAddress, tokenId), function () {
    var _contract$drop4, _contract$drop4$claim, _contract$drop4$claim2, _contract$drop6, _contract$drop6$claim, _contract$drop6$claim2;

    invariant(contract, "No Contract instance provided");
    invariant(contract === null || contract === void 0 ? void 0 : (_contract$drop4 = contract.drop) === null || _contract$drop4 === void 0 ? void 0 : (_contract$drop4$claim = _contract$drop4.claim) === null || _contract$drop4$claim === void 0 ? void 0 : (_contract$drop4$claim2 = _contract$drop4$claim.conditions) === null || _contract$drop4$claim2 === void 0 ? void 0 : _contract$drop4$claim2.getAll, "Contract instance does not support drop.claim.conditions.getAll");

    if (contract instanceof Erc1155) {
      var _contract$drop5, _contract$drop5$claim, _contract$drop5$claim2;

      invariant(tokenId, "tokenId is required for ERC1155 claim conditions");
      return contract === null || contract === void 0 ? void 0 : (_contract$drop5 = contract.drop) === null || _contract$drop5 === void 0 ? void 0 : (_contract$drop5$claim = _contract$drop5.claim) === null || _contract$drop5$claim === void 0 ? void 0 : (_contract$drop5$claim2 = _contract$drop5$claim.conditions) === null || _contract$drop5$claim2 === void 0 ? void 0 : _contract$drop5$claim2.getAll(tokenId);
    }

    return contract === null || contract === void 0 ? void 0 : (_contract$drop6 = contract.drop) === null || _contract$drop6 === void 0 ? void 0 : (_contract$drop6$claim = _contract$drop6.claim) === null || _contract$drop6$claim === void 0 ? void 0 : (_contract$drop6$claim2 = _contract$drop6$claim.conditions) === null || _contract$drop6$claim2 === void 0 ? void 0 : _contract$drop6$claim2.getAll();
  }, {
    // Checks that happen here:
    // 1. if the contract is based on ERC1155 contract => tokenId cannot be `undefined`
    // 2. if the contract is NOT based on ERC1155 => contract has to still be provided
    enabled: contract instanceof Erc1155 ? tokenId !== undefined : !!contract
  });
}
/**
 * Use this to check for reasons that prevent claiming for either  ERC20, ERC721 or ERC1155 based contracts. They need to extend the `claimCondition` extension for this hook to work.
 * @example
 * ```javascript
 * const { data: activeClaimCondition, isLoading, error } = useClaimIneligibilityReasons(<YourERC20ContractInstance>, { walletAddress: <walletAddress> });
 * ```
 * @example
 * ```javascript
 * const { data: claimIneligibilityReasons, isLoading, error } = useClaimIneligibilityReasons(<YourERC721ContractInstance>, { quantity: <quantity>, walletAddress: <walletAddress> });
 * ```
 * @example
 * ```javascript
 * const { data: claimIneligibilityReasons, isLoading, error } = useClaimIneligibilityReasons(<YourERC1155ContractInstance>, { quantity: <quantity>, walletAddress: <walletAddress> }, <tokenId>);
 * ```
 *
 * @param contract - an instance of a contract that extends the  ERC20, ERC721 or ERC1155 spec and implements the `claimConditions` extension.
 * @param eligibilityParams - the parameters for the eligibility check, see: {@link ClaimIneligibilityParameters}
 * @param tokenId - the id of the token to fetch the claim conditions for (if the contract is an ERC1155 contract)
 * @returns a response object with the resons for the claim ineligibility
 *
 * @beta
 */

function useClaimIneligibilityReasons() {
  for (var _len3 = arguments.length, _ref3 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    _ref3[_key3] = arguments[_key3];
  }

  var contract = _ref3[0],
      params = _ref3[1],
      tokenId = _ref3[2];
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.claimConditions.getClaimIneligibilityReasons(contractAddress, params, tokenId), function () {
    var _contract$drop7, _contract$drop7$claim, _contract$drop9, _contract$drop9$claim;

    invariant(contract, "No Contract instance provided");
    invariant(contract === null || contract === void 0 ? void 0 : (_contract$drop7 = contract.drop) === null || _contract$drop7 === void 0 ? void 0 : (_contract$drop7$claim = _contract$drop7.claim) === null || _contract$drop7$claim === void 0 ? void 0 : _contract$drop7$claim.conditions.getClaimIneligibilityReasons, "Contract instance does not support claimConditions.getClaimIneligibilityReasons");

    if (contract instanceof Erc1155) {
      var _contract$drop8, _contract$drop8$claim;

      invariant(tokenId, "tokenId is required for ERC1155 claim ineligibility reasons");
      return contract === null || contract === void 0 ? void 0 : (_contract$drop8 = contract.drop) === null || _contract$drop8 === void 0 ? void 0 : (_contract$drop8$claim = _contract$drop8.claim) === null || _contract$drop8$claim === void 0 ? void 0 : _contract$drop8$claim.conditions.getClaimIneligibilityReasons(tokenId, params.quantity, params.walletAddress);
    }

    return contract === null || contract === void 0 ? void 0 : (_contract$drop9 = contract.drop) === null || _contract$drop9 === void 0 ? void 0 : (_contract$drop9$claim = _contract$drop9.claim) === null || _contract$drop9$claim === void 0 ? void 0 : _contract$drop9$claim.conditions.getClaimIneligibilityReasons(params.quantity, params.walletAddress);
  }, {
    // Checks that happen here:
    // 1. if the contract is based on ERC1155 contract => tokenId cannot be `undefined`
    // 2. if the contract is NOT based on ERC1155 => contract has to still be provided
    // 3. has a params object been passed?
    // 4. does params have an address in it?
    enabled: (contract instanceof Erc1155 ? tokenId !== undefined : !!contract) && !!params && !!params.walletAddress
  });
}
/** **********************/

/**     WRITE HOOKS     **/

/** **********************/

/**
 * Use this to set claim conditions on your {@link NFTContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const nftDrop = useNFTDrop(<ContractAddress>);
 *   const {
 *     mutate: setClaimConditions,
 *     isLoading,
 *     error,
 *   } = useSetClaimConditions(nftDrop);
 *
 *   if (error) {
 *     console.error("failed to set claim conditions", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => setClaimConditions({ phases: [{ price: 2, maxQuantity: 100 }] })}
 *     >
 *       Set Claim Conditions!
 *     </button>
 *   );
 * };
 * ```
 * @example
 * ```jsx
 * const Component = () => {
 *   const { contract } = useContract(<ContractAddress>);
 *   const {
 *     mutate: setClaimConditions,
 *     isLoading,
 *     error,
 *   } = useSetClaimConditions(contract?.nft);
 *
 *   if (error) {
 *     console.error("failed to set claim conditions", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => setClaimConditions({ phases: [{ price: 2, maxQuantity: 100 }] })}
 *     >
 *       Set Claim Conditions!
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @returns a mutation object that can be used to set claim conditions
 * @beta
 */

function useSetClaimConditions() {
  for (var _len4 = arguments.length, _ref4 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    _ref4[_key4] = arguments[_key4];
  }

  var contract = _ref4[0],
      tokenId = _ref4[1];
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  return useMutation( /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(data) {
      var _contract$drop11, _contract$drop11$clai;

      var phases, _data$reset, reset, _contract$drop10, _contract$drop10$clai;

      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              invariant(contract, "No Contract instance provided");
              phases = data.phases, _data$reset = data.reset, reset = _data$reset === void 0 ? false : _data$reset;
              invariant(phases, 'No "phases" provided');

              if (!(contract instanceof Erc1155)) {
                _context.next = 6;
                break;
              }

              invariant(tokenId, "tokenId is required for ERC1155 claim conditions");
              return _context.abrupt("return", contract === null || contract === void 0 ? void 0 : (_contract$drop10 = contract.drop) === null || _contract$drop10 === void 0 ? void 0 : (_contract$drop10$clai = _contract$drop10.claim) === null || _contract$drop10$clai === void 0 ? void 0 : _contract$drop10$clai.conditions.set(tokenId, phases, reset));

            case 6:
              return _context.abrupt("return", contract === null || contract === void 0 ? void 0 : (_contract$drop11 = contract.drop) === null || _contract$drop11 === void 0 ? void 0 : (_contract$drop11$clai = _contract$drop11.claim) === null || _contract$drop11$clai === void 0 ? void 0 : _contract$drop11$clai.conditions.set(phases, reset));

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref5.apply(this, arguments);
    };
  }(), {
    onSettled: function onSettled() {
      invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}
/**
 * Use this to reset claim conditions on your {@link NFTContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const nftDrop = useNFTDrop(<ContractAddress>);
 *   const {
 *     mutate: resetClaimConditions,
 *     isLoading,
 *     error,
 *   } = useResetClaimConditions(nftDrop);
 *
 *   if (error) {
 *     console.error("failed to reset claim conditions", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={resetClaimConditions}
 *     >
 *       Reset Claim Conditions
 *     </button>
 *   );
 * };
 * ```
 * @example
 * ```jsx
 * const Component = () => {
 *   const { contract } = useContract(<ContractAddress>);
 *   const {
 *     mutate: resetClaimConditions,
 *     isLoading,
 *     error,
 *   } = useResetClaimConditions(contract?.nft);
 *
 *   if (error) {
 *     console.error("failed to reset claim conditions", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={resetClaimConditions}
 *     >
 *       Reset Claim Conditions
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link NFTContract}
 * @returns a mutation object that can be used to reset claim conditions
 * @beta
 */

function useResetClaimConditions() {
  for (var _len5 = arguments.length, _ref6 = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    _ref6[_key5] = arguments[_key5];
  }

  var contract = _ref6[0],
      tokenId = _ref6[1];
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  return useMutation( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var _contract$drop14, _contract$drop14$clai, _contract$drop15, _contract$drop15$clai;

    var cleanConditions, _contract$drop12, _contract$drop12$clai, _contract$drop13, _contract$drop13$clai, _claimConditions, claimConditions;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            invariant(contract, "No Contract instance provided");

            cleanConditions = function cleanConditions(conditions) {
              return conditions.map(function (c) {
                return _objectSpread2(_objectSpread2({}, c), {}, {
                  price: c.currencyMetadata.displayValue,
                  maxQuantity: c.maxQuantity.toString(),
                  quantityLimitPerTransaction: c.quantityLimitPerTransaction.toString()
                });
              });
            };

            if (!(contract instanceof Erc1155)) {
              _context2.next = 8;
              break;
            }

            invariant(tokenId, "tokenId is required for ERC1155 claim conditions");
            _context2.next = 6;
            return contract === null || contract === void 0 ? void 0 : (_contract$drop12 = contract.drop) === null || _contract$drop12 === void 0 ? void 0 : (_contract$drop12$clai = _contract$drop12.claim) === null || _contract$drop12$clai === void 0 ? void 0 : _contract$drop12$clai.conditions.getAll(tokenId);

          case 6:
            _claimConditions = _context2.sent;
            return _context2.abrupt("return", contract === null || contract === void 0 ? void 0 : (_contract$drop13 = contract.drop) === null || _contract$drop13 === void 0 ? void 0 : (_contract$drop13$clai = _contract$drop13.claim) === null || _contract$drop13$clai === void 0 ? void 0 : _contract$drop13$clai.conditions.set(tokenId, cleanConditions(_claimConditions || []), true));

          case 8:
            _context2.next = 10;
            return contract === null || contract === void 0 ? void 0 : (_contract$drop14 = contract.drop) === null || _contract$drop14 === void 0 ? void 0 : (_contract$drop14$clai = _contract$drop14.claim) === null || _contract$drop14$clai === void 0 ? void 0 : _contract$drop14$clai.conditions.getAll();

          case 10:
            claimConditions = _context2.sent;
            _context2.next = 13;
            return contract === null || contract === void 0 ? void 0 : (_contract$drop15 = contract.drop) === null || _contract$drop15 === void 0 ? void 0 : (_contract$drop15$clai = _contract$drop15.claim) === null || _contract$drop15$clai === void 0 ? void 0 : _contract$drop15$clai.conditions.set(cleanConditions(claimConditions || []), true);

          case 13:
            return _context2.abrupt("return", _context2.sent);

          case 14:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  })), {
    onSettled: function onSettled() {
      invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}

/**
 * A hook to get the native or (optional) ERC20 token balance of the connected wallet.
 *
 * @param tokenAddress - the address of the token contract, if empty will use the chain's native token
 * @returns the balance of the connected wallet (native or ERC20)
 * @beta
 */

function useBalance(tokenAddress) {
  var _useThirdwebConfigCon = useThirdwebConfigContext(),
      rpcUrlMap = _useThirdwebConfigCon.rpcUrlMap;

  var chainId = useChainId();
  var signer = useSigner();
  var walletAddress = useAddress();
  var walletSDK = useMemo(function () {
    if (signer) {
      var rpcUrl = rpcUrlMap[chainId];
      return new UserWallet(signer, {
        readonlySettings: rpcUrl ? {
          rpcUrl: rpcUrl,
          chainId: chainId
        } : undefined
      });
    }

    return undefined;
  }, [signer, chainId]);
  var cacheKey = useMemo(function () {
    return cacheKeys.wallet.balance(chainId, walletAddress, tokenAddress);
  }, [chainId, tokenAddress, walletAddress]);
  return useQuery(cacheKey, function () {
    return walletSDK === null || walletSDK === void 0 ? void 0 : walletSDK.balance(tokenAddress);
  }, {
    // if user is not logged in no reason to try to fetch
    enabled: !!walletSDK && !!walletAddress,
    retry: true,
    keepPreviousData: false
  });
}

/**
 *
 * @example
 * ```jsx
 * const { data: recipient, isLoading, error } = usePrimarySalesRecipient(SmartContract);
 * ```
 *
 * Use this to get the primary sales recipient of your {@link SmartContract}
 * @param contract - an instance of a {@link SmartContract}
 * @returns the wallet address of the primary sales recipient
 * @beta
 */

function usePrimarySaleRecipient(contract) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.sales.getRecipient(contractAddress), function () {
    invariant(contract, "No contract provided");
    invariant("sales" in contract && contract.sales, "Contract does not support primarySale");
    return contract.sales.getRecipient();
  }, {
    enabled: !!contract || !!contractAddress
  });
}
/**
 * Use this to update the primary sales recipient of your {@link SmartContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: updatePrimarySalesRecipient,
 *     isLoading,
 *     error,
 *   } = useUpdatePrimarySaleRecipient(SmartContract);
 *
 *   if (error) {
 *     console.error("failed to update recipient", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => updatePrimarySalesRecipient({ newRecipient: "0x123" })}
 *     >
 *       Update Recipient
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @returns a mutation object that can be used to update the primary sales recipient
 * @beta
 */

function useUpdatePrimarySaleRecipient(contract) {
  var queryClient = useQueryClient();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var activeChainId = useActiveChainId();
  return useMutation(function (newRecipient) {
    invariant(contract, "No contract provided");
    invariant("sales" in contract && contract.sales, "Contract does not support primarySale");
    return contract.sales.setRecipient(newRecipient);
  }, {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
} // end prinary sales
// royalties

/**
 * Use this to get the royalty settings of your {@link SmartContract}
 *
 * @example
 * ```jsx
 * const { data: settings, isLoading, error } = useRoyaltySettings(SmartContract);
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @returns an object containing recipient address and the royalty basis points
 * @beta
 */

function useRoyaltySettings(contract) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.royalties.getDefaultRoyaltyInfo(contractAddress), function () {
    invariant(contract, "No contract provided");
    invariant("royalties" in contract && contract.royalties, "Contract does not support royalties");
    return contract.royalties.getDefaultRoyaltyInfo();
  }, {
    enabled: !!contract || !!contractAddress
  });
}
/**
 * Use this to update the royalty settings of your {@link SmartContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: updateRoyaltySettings,
 *     isLoading,
 *     error,
 *   } = useUpdateRoyaltySettings(SmartContract);
 *
 *   if (error) {
 *     console.error("failed to update royalty settings", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => updateRoyaltySettings({ updatePayload: { fee_recipient: "0x123", seller_fee_basis_points: 5_00 } })}
 *     >
 *       Update Royalty Settings
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @returns a mutation object that can be used to update the royalty settings
 * @beta
 */

function useUpdateRoyaltySettings(contract) {
  var queryClient = useQueryClient();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var activeChainId = useActiveChainId();
  return useMutation(function (updatePayload) {
    invariant(contract, "No contract provided");
    invariant("royalties" in contract && contract.royalties, "Contract does not support royalties");
    return contract.royalties.setDefaultRoyaltyInfo(updatePayload);
  }, {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
} // end royalties
// platformFees

/**
 * Use this to get the platform fees settings of your {@link SmartContract}
 *
 * @example
 * ```jsx
 * const { data: platformFees, isLoading, error } = usePlatformFees(SmartContract);
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @returns an object containing the platform fee basis points and the fee recipient address
 * @beta
 */

function usePlatformFees(contract) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.platformFees.get(contractAddress), function () {
    invariant(contract, "No contract provided");
    invariant("platformFees" in contract && contract.platformFees, "Contract does not support platformFees");
    return contract.platformFees.get();
  }, {
    enabled: !!contract || !!contractAddress
  });
}
/**
 * Use this to update the platform fees settings of your {@link SmartContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: updatePlatformFees,
 *     isLoading,
 *     error,
 *   } = useUpdatePlatformFees(SmartContract);
 *
 *   if (error) {
 *     console.error("failed to update platform fees", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => updatePlatformFees({ updatePayload: { fee_recipient: "0x123", platform_fee_basis_points: 5_00 } })}
 *     >
 *       Update Platform fees
 *     </button>
 *   );
 * };
 * ```
 * @param contract - an instance of a {@link SmartContract}
 * @returns a mutation object that can be used to update the platform fees settings
 * @beta
 */

function useUpdatePlatformFees(contract) {
  var queryClient = useQueryClient();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var activeChainId = useActiveChainId();
  return useMutation(function (updatePayload) {
    invariant(contract, "No contract provided");
    invariant("platformFees" in contract && contract.platformFees, "Contract does not support platformFees");
    return contract.platformFees.set(updatePayload);
  }, {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
} // end platformFees
// metadata

/**
 * Use this to get the metadata of your {@link SmartContract}
 *
 * @example
 * ```jsx
 * const { data: metadata, isLoading, error } = useMetadata(SmartContract);
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @returns a {@link CustomContractMetadata} object containing the metadata
 * @beta
 */

function useMetadata(contract) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.metadata.get(contractAddress), function () {
    invariant(contract, "No contract provided");
    invariant("metadata" in contract && contract.metadata, "Contract does not support metadata");
    return contract.metadata.get();
  }, {
    enabled: !!contract || !!contractAddress
  });
}
/**
 * Use this to update the metadata of your {@link SmartContract}
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: updateMetadata,
 *     isLoading,
 *     error,
 *   } = useUpdateMetadata(SmartContract);
 *
 *   if (error) {
 *     console.error("failed to update metadata", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => updateMetadata({ updatePayload: { name: "My Contract", description: "This is my contract" } })}
 *     >
 *       Update Metadata
 *     </button>
 *   );
 * };
 * ```
 * @param contract - an instance of a {@link SmartContract}
 * @returns a mutation object that can be used to update the metadata
 * @beta
 */

function useUpdateMetadata(contract) {
  var queryClient = useQueryClient();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var activeChainId = useActiveChainId();
  return useMutation(function (updatePayload) {
    invariant(contract, "No contract provided");
    invariant("metadata" in contract && contract.metadata, "Contract does not support metadata");
    return contract.metadata.update(updatePayload);
  }, {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
} // end metadata

/** **********************/

/**         UTILS       **/

/** **********************/

/**
 * @internal
 */

/** **********************/

/**     READ  HOOKS     **/

/** **********************/

/**
 * Use this to get the roles of a {@link SmartContract}
 *
 * @example
 * ```jsx
 * const { data: roles, isLoading, error } = useAllRoleMembers(SmartContract);
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @returns a list of addresses for all supported roles on the contract.
 * @beta
 */
function useAllRoleMembers(contract) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.roles.getAll(contractAddress), function () {
    invariant(contract, "No contract provided");
    invariant(contract.roles, "Contract does not support roles"); // have to cast to any because of role bs, type is defined in the useQueryWithNetwork definition above

    return contract.roles.getAll();
  }, {
    enabled: !!contract && !!contractAddress
  });
}
/**
 * Use this to get the members of a role on a {@link SmartContract}
 *
 * @example
 * ```jsx
 * const { data: members, isLoading, error } = useRoleMembers(SmartContract, "admin");
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @param role - the role to get the members of, see {@link Role}
 * @returns a list of addresses that are members of the role
 * @beta
 */

function useRoleMembers(contract, role) {
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  return useQueryWithNetwork(cacheKeys.extensions.roles.get(contractAddress, role), function () {
    invariant(contract, "No contract provided");
    invariant(contract.roles, "Contract does not support roles");
    return contract.roles.get(role);
  }, {
    enabled: !!contract && !!contractAddress && !!role
  });
}
/**
 * Use this to check if a {@link WalletAddress} is a member of a role on a {@link SmartContract}
 *
 * @example
 * ```jsx
 * const { data: isMember, isLoading, error } = useIsAddressRole(SmartContract, "admin", "0x123");
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @param role - the role to check the member against, see {@link Role}
 * @param walletAddress - the address to check
 * @returns true if the address is a member of the role, or false if not
 * @beta
 */

function useIsAddressRole(contract, role, walletAddress) {
  // TODO this might be possible to do with `verify` fn instead?
  var contractHasRoles = !!(contract && contract.roles);

  var _useRoleMembers = useRoleMembers(contractHasRoles ? contract : undefined, role),
      data = _useRoleMembers.data; // if the contract does not have roles then everything is allowed === true


  if (contractHasRoles === false) {
    return true;
  } // switch logic (if address 0 is in the role list then anyone has permissions to it)


  if (data !== null && data !== void 0 && data.includes(constants.AddressZero)) {
    return true;
  } // actual role check logic


  return !!(walletAddress && data !== null && data !== void 0 && data.includes(walletAddress));
}
/** **********************/

/**     WRITE HOOKS     **/

/** **********************/

/**
 * Use this to OVERWRITE the list of addresses that are members of specific roles
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: overwriteRoles,
 *     isLoading,
 *     error,
 *   } = useSetAllRoleMembers(SmartContract);
 *
 *   if (error) {
 *     console.error("failed to overwrite roles", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => overwriteRoles({  rolesWithAddresses: { minter: [] } })}
 *     >
 *       Overwrite Roles
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @returns a mutation object that can be used to overwrite all roles on the contract
 * @beta
 */

function useSetAllRoleMembers(contract) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  return useMutation( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(rolesWithAddresses) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              invariant(contract, "No contract provided");
              invariant(contract.roles, "Contract does not support roles");
              _context.next = 4;
              return contract.roles.setAll(rolesWithAddresses);

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
} // const { mutate } = useSetAllRoleMembers(undefined as unknown as NFTCollection);

/**
 * Use this to grant a {@link WalletAddress} a specific role on a {@link SmartContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: grantRole,
 *     isLoading,
 *     error,
 *   } = useGrantRole(SmartContract);
 *
 *   if (error) {
 *     console.error("failed to grant role", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => grantRole({  role: "admin", address: "0x123" })}
 *     >
 *       Grant Role
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @returns a mutation object that can be used to grant a member of a role on the contract
 * @beta
 */

function useGrantRole(contract) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  return useMutation( /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              invariant(contract, "No contract provided");
              invariant(contract.roles, "Contract does not support roles");
              _context2.next = 4;
              return contract.roles.grant(params.role, params.address);

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x2) {
      return _ref2.apply(this, arguments);
    };
  }(), {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}
/**
 * Use this to revoke a {@link WalletAddress} a specific role on a {@link SmartContract}
 *
 * @example
 * ```jsx
 * const Component = () => {
 *   const {
 *     mutate: revokeRole,
 *     isLoading,
 *     error,
 *   } = useRevokeRole(SmartContract);
 *
 *   if (error) {
 *     console.error("failed to revoke role", error);
 *   }
 *
 *   return (
 *     <button
 *       disabled={isLoading}
 *       onClick={() => revokeRole({  role: "admin", address: "0x123" })}
 *     >
 *       Revoke Role
 *     </button>
 *   );
 * };
 * ```
 *
 * @param contract - an instance of a {@link SmartContract}
 * @returns a mutation object that can be used to revoke a role from a member on the contract
 * @beta
 */

function useRevokeRole(contract) {
  var activeChainId = useActiveChainId();
  var contractAddress = contract === null || contract === void 0 ? void 0 : contract.getAddress();
  var queryClient = useQueryClient();
  return useMutation( /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(params) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              invariant(contract, "No contract provided");
              invariant(contract.roles, "Contract does not support roles");
              _context3.next = 4;
              return contract.roles.revoke(params.role, params.address);

            case 4:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function (_x3) {
      return _ref3.apply(this, arguments);
    };
  }(), {
    onSettled: function onSettled() {
      return invalidateContractAndBalances(queryClient, contractAddress, activeChainId);
    }
  });
}

var DEFAULT_IPFS_GATEWAY = "https://gateway.ipfscdn.io/ipfs/";
var DEFAULT_IPFS_RESOLVER_OPTIONS = {
  gatewayUrl: DEFAULT_IPFS_GATEWAY
};

function resolveIpfsUri(uri) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_IPFS_RESOLVER_OPTIONS;

  if (!uri) {
    return undefined;
  }

  if (uri.startsWith("ipfs://")) {
    return uri.replace("ipfs://", options.gatewayUrl);
  }

  return uri;
}
function resolveMimeType(_x) {
  return _resolveMimeType.apply(this, arguments);
}

function _resolveMimeType() {
  _resolveMimeType = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(url) {
    var mimeType, res, _res$headers$get;

    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (url) {
              _context.next = 2;
              break;
            }

            return _context.abrupt("return", undefined);

          case 2:
            mimeType = mime.getType(url);

            if (!mimeType) {
              _context.next = 5;
              break;
            }

            return _context.abrupt("return", mimeType);

          case 5:
            _context.next = 7;
            return fetch(url, {
              method: "HEAD"
            });

          case 7:
            res = _context.sent;

            if (!(res.ok && res.headers.has("content-type"))) {
              _context.next = 10;
              break;
            }

            return _context.abrupt("return", (_res$headers$get = res.headers.get("content-type")) !== null && _res$headers$get !== void 0 ? _res$headers$get : undefined);

          case 10:
            return _context.abrupt("return", undefined);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _resolveMimeType.apply(this, arguments);
}

var video;

function supportsVideoType(mimeType) {
  if (!mimeType || !mimeType.startsWith("video/")) {
    return "";
  }

  if (!video) {
    video = document.createElement("video");
  }

  return video.canPlayType(mimeType);
}

function shouldRenderVideoTag(mimeType) {
  return !!supportsVideoType(mimeType);
}
var audio;

function supportsAudioType(mimeType) {
  if (!mimeType || !mimeType.startsWith("audio/")) {
    return "";
  }

  if (!audio) {
    audio = document.createElement("audio");
  }

  return audio.canPlayType(mimeType);
}

function shouldRenderAudioTag(mimeType) {
  return !!supportsAudioType(mimeType);
}

function mergeRefs(refs) {
  return function (value) {
    refs.forEach(function (ref) {
      if (typeof ref === "function") {
        ref(value); // eslint-disable-next-line eqeqeq
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}

var CarbonDocumentUnknown = function CarbonDocumentUnknown(props) {
  return /*#__PURE__*/jsxs("svg", _objectSpread2(_objectSpread2({
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32"
  }, props), {}, {
    children: [/*#__PURE__*/jsx("circle", {
      cx: "9",
      cy: "28.5",
      r: "1.5",
      fill: "currentColor"
    }), /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M10 25H8v-4h2a2 2 0 0 0 0-4H8a2.002 2.002 0 0 0-2 2v.5H4V19a4.005 4.005 0 0 1 4-4h2a4 4 0 0 1 0 8Z"
    }), /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "m27.7 9.3l-7-7A.908.908 0 0 0 20 2H10a2.006 2.006 0 0 0-2 2v8h2V4h8v6a2.006 2.006 0 0 0 2 2h6v16H14v2h12a2.006 2.006 0 0 0 2-2V10a.91.91 0 0 0-.3-.7ZM20 10V4.4l5.6 5.6Z"
    })]
  }));
};
var CarbonDocumentAudio = function CarbonDocumentAudio(props) {
  return /*#__PURE__*/jsxs("svg", _objectSpread2(_objectSpread2({
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32"
  }, props), {}, {
    children: [/*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M29 31a.999.999 0 0 1-.625-.22L23.65 27H20a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1h3.65l4.726-3.78A1 1 0 0 1 30 17v13a1 1 0 0 1-1 1Zm-8-6h3a1 1 0 0 1 .625.22L28 27.92v-8.84l-3.376 2.7A1 1 0 0 1 24 22h-3Z"
    }), /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M16 28H8V4h8v6a2.006 2.006 0 0 0 2 2h6v3h2v-5a.91.91 0 0 0-.3-.7l-7-7A.909.909 0 0 0 18 2H8a2.006 2.006 0 0 0-2 2v24a2.006 2.006 0 0 0 2 2h8Zm2-23.6l5.6 5.6H18Z"
    })]
  }));
};
var CarbonPauseFilled = function CarbonPauseFilled(props) {
  return /*#__PURE__*/jsx("svg", _objectSpread2(_objectSpread2({
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32"
  }, props), {}, {
    children: /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M12 6h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm10 0h-2a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2z"
    })
  }));
};
var CarbonPlayFilledAlt = function CarbonPlayFilledAlt(props) {
  return /*#__PURE__*/jsx("svg", _objectSpread2(_objectSpread2({
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32"
  }, props), {}, {
    children: /*#__PURE__*/jsx("path", {
      fill: "currentColor",
      d: "M7 28a1 1 0 0 1-1-1V5a1 1 0 0 1 1.482-.876l20 11a1 1 0 0 1 0 1.752l-20 11A1 1 0 0 1 7 28Z"
    })
  }));
};

var _excluded$7 = ["src", "alt", "poster", "requireInteraction", "children", "style", "width", "height", "controls"],
    _excluded2 = ["src", "alt", "poster", "requireInteraction", "children", "style", "height", "width", "controls"],
    _excluded3 = ["src", "alt", "poster", "requireInteraction", "children", "style", "height", "width", "controls"],
    _excluded4 = ["src", "alt", "poster", "requireInteraction", "children", "style", "height", "width", "controls"],
    _excluded5 = ["children", "src", "poster", "alt", "requireInteraction", "style"];

var PlayButton = function PlayButton(_ref) {
  var onClick = _ref.onClick,
      isPlaying = _ref.isPlaying;

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isHovering = _useState2[0],
      setIsHovering = _useState2[1];

  var onMouseEnter = function onMouseEnter() {
    return setIsHovering(true);
  };

  var onMouseLeave = function onMouseLeave() {
    return setIsHovering(false);
  };

  var onMouseDown = function onMouseDown() {
    return setIsHovering(false);
  };

  var onMouseUp = function onMouseUp() {
    return setIsHovering(true);
  };

  return /*#__PURE__*/jsx("button", {
    style: _objectSpread2({
      position: "absolute",
      bottom: 0,
      right: 0,
      transform: "translate(-25%, -25%)",
      maxWidth: "32px",
      width: "8%",
      minWidth: "24px",
      aspectRatio: "1",
      zIndex: 3,
      backgroundColor: "#fff",
      color: "rgb(138, 147, 155)",
      display: "grid",
      placeItems: "center",
      borderRadius: "50%",
      border: "1px solid rgb(229, 232, 235)",
      cursor: "pointer"
    }, isHovering ? {
      color: "rgb(53, 56, 64)",
      boxShadow: "rgb(4 17 29 / 25%) 0px 0px 8px 0px"
    } : {}),
    onClick: onClick,
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave,
    onMouseDown: onMouseDown,
    onMouseUp: onMouseUp,
    children: !isPlaying ? /*#__PURE__*/jsx(CarbonPlayFilledAlt, {
      style: {
        width: "66%",
        height: "66%"
      }
    }) : /*#__PURE__*/jsx(CarbonPauseFilled, {
      style: {
        width: "66%",
        height: "66%"
      }
    })
  });
};

var VideoPlayer = /*#__PURE__*/React.forwardRef(function (_ref2, ref) {
  var src = _ref2.src;
      _ref2.alt;
      var poster = _ref2.poster,
      requireInteraction = _ref2.requireInteraction;
      _ref2.children;
      var style = _ref2.style,
      width = _ref2.width,
      height = _ref2.height,
      controls = _ref2.controls,
      restProps = _objectWithoutProperties(_ref2, _excluded$7);

  var videoRef = useRef(null);

  var _useState3 = useState(!requireInteraction),
      _useState4 = _slicedToArray(_useState3, 2),
      playing = _useState4[0],
      setPlaying = _useState4[1];

  var _useState5 = useState(true),
      _useState6 = _slicedToArray(_useState5, 2),
      muted = _useState6[0],
      setMuted = _useState6[1];

  useEffect(function () {
    if (videoRef.current) {
      if (playing) {
        videoRef.current.play();
      } else {
        videoRef.current.pause();
        videoRef.current.currentTime = 0;
      }
    }
  }, [playing]);
  return /*#__PURE__*/jsxs("div", _objectSpread2(_objectSpread2({
    style: _objectSpread2({
      position: "relative"
    }, style)
  }, restProps), {}, {
    children: [/*#__PURE__*/jsx("video", {
      ref: mergeRefs([videoRef, ref]),
      src: src !== null && src !== void 0 ? src : undefined,
      poster: poster !== null && poster !== void 0 ? poster : undefined,
      loop: true,
      playsInline: true,
      muted: muted,
      preload: poster ? "metadata" : "auto",
      onCanPlay: function onCanPlay() {
        if (playing) {
          var _videoRef$current;

          (_videoRef$current = videoRef.current) === null || _videoRef$current === void 0 ? void 0 : _videoRef$current.play();
        }
      },
      width: width,
      height: height,
      controls: controls,
      style: {
        height: "100%",
        width: "100%",
        objectFit: "contain",
        zIndex: 1,
        transition: "opacity .5s",
        opacity: !poster ? 1 : playing ? 1 : 0
      }
    }), poster && /*#__PURE__*/jsx("img", {
      src: poster,
      style: {
        objectFit: "contain",
        pointerEvents: "none",
        position: "absolute",
        width: "100%",
        height: "100%",
        zIndex: 2,
        transition: "opacity .5s",
        opacity: playing ? 0 : 1,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      }
    }), /*#__PURE__*/jsx(PlayButton, {
      onClick: function onClick() {
        setPlaying(function (prev) {
          return !prev;
        });
        setMuted(false);
      },
      isPlaying: playing
    })]
  }));
});
var AudioPlayer = /*#__PURE__*/React.forwardRef(function (_ref3, ref) {
  var src = _ref3.src;
      _ref3.alt;
      var poster = _ref3.poster;
      _ref3.requireInteraction;
      _ref3.children;
      var style = _ref3.style,
      height = _ref3.height,
      width = _ref3.width;
      _ref3.controls;
      var restProps = _objectWithoutProperties(_ref3, _excluded2);

  var audioRef = useRef(null);

  var _useState7 = useState(false),
      _useState8 = _slicedToArray(_useState7, 2),
      playing = _useState8[0],
      setPlaying = _useState8[1];

  var _useState9 = useState(true),
      _useState10 = _slicedToArray(_useState9, 2),
      muted = _useState10[0],
      setMuted = _useState10[1];

  useEffect(function () {
    if (audioRef.current) {
      if (playing) {
        audioRef.current.play();
      } else {
        audioRef.current.pause();
        audioRef.current.currentTime = 0;
      }
    }
  }, [playing]);
  return /*#__PURE__*/jsxs("div", _objectSpread2(_objectSpread2({
    style: _objectSpread2({
      position: "relative"
    }, style)
  }, restProps), {}, {
    children: [poster ? /*#__PURE__*/jsx("img", {
      height: height,
      width: width,
      src: poster,
      style: {
        height: "100%",
        width: "100%",
        pointerEvents: "none",
        objectFit: "contain"
      }
    }) : /*#__PURE__*/jsx("div", {
      style: {
        width: "100%",
        height: "100%",
        display: "grid",
        placeItems: "center",
        pointerEvents: "none",
        backgroundColor: "#fff",
        color: "rgb(138, 147, 155)"
      },
      children: /*#__PURE__*/jsx(CarbonDocumentAudio, {
        style: {
          height: "64px",
          width: "64px"
        }
      })
    }), /*#__PURE__*/jsx(PlayButton, {
      onClick: function onClick() {
        setPlaying(function (prev) {
          return !prev;
        });
        setMuted(false);
      },
      isPlaying: playing
    }), /*#__PURE__*/jsx("audio", {
      ref: mergeRefs([audioRef, ref]),
      src: src !== null && src !== void 0 ? src : undefined,
      loop: true,
      playsInline: true,
      muted: muted,
      style: {
        position: "absolute",
        opacity: 0,
        pointerEvents: "none",
        zIndex: -1,
        visibility: "hidden"
      }
    })]
  }));
});
var IframePlayer = /*#__PURE__*/React.forwardRef(function (_ref4, ref) {
  var src = _ref4.src,
      alt = _ref4.alt,
      poster = _ref4.poster,
      requireInteraction = _ref4.requireInteraction;
      _ref4.children;
      var style = _ref4.style;
      _ref4.height;
      _ref4.width;
      _ref4.controls;
      var restProps = _objectWithoutProperties(_ref4, _excluded3);

  var _useDimensions = useDimensions(),
      observe = _useDimensions.observe,
      elWidth = _useDimensions.width;

  var _useState11 = useState(!requireInteraction),
      _useState12 = _slicedToArray(_useState11, 2),
      playing = _useState12[0],
      setPlaying = _useState12[1];

  if (elWidth < 300) {
    return /*#__PURE__*/jsx("div", {
      ref: observe,
      children: /*#__PURE__*/jsx(LinkPlayer, _objectSpread2({
        style: style,
        src: src,
        alt: alt
      }, restProps))
    });
  }

  return /*#__PURE__*/jsxs("div", _objectSpread2(_objectSpread2({
    style: _objectSpread2({
      position: "relative"
    }, style)
  }, restProps), {}, {
    ref: observe,
    children: [/*#__PURE__*/jsx("iframe", {
      src: playing ? src !== null && src !== void 0 ? src : undefined : undefined,
      ref: ref,
      style: {
        objectFit: "contain",
        zIndex: 1,
        height: "100%",
        width: "100%",
        transition: "opacity .5s",
        opacity: !poster ? 1 : playing ? 1 : 0
      }
    }), poster && /*#__PURE__*/jsx("img", {
      src: poster,
      style: {
        objectFit: "contain",
        pointerEvents: "none",
        position: "absolute",
        width: "100%",
        height: "100%",
        zIndex: 2,
        transition: "opacity .5s",
        opacity: playing ? 0 : 1,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      }
    }), /*#__PURE__*/jsx(PlayButton, {
      onClick: function onClick() {
        setPlaying(function (prev) {
          return !prev;
        });
      },
      isPlaying: playing
    })]
  }));
});
var LinkPlayer = /*#__PURE__*/React.forwardRef(function (_ref5, ref) {
  var src = _ref5.src,
      alt = _ref5.alt;
      _ref5.poster;
      _ref5.requireInteraction;
      _ref5.children;
      var style = _ref5.style;
      _ref5.height;
      _ref5.width;
      _ref5.controls;
      var restProps = _objectWithoutProperties(_ref5, _excluded4);

  return /*#__PURE__*/jsx("div", _objectSpread2(_objectSpread2({
    style: _objectSpread2({
      position: "relative"
    }, style)
  }, restProps), {}, {
    children: /*#__PURE__*/jsx("div", {
      style: {
        width: "100%",
        height: "100%",
        display: "grid",
        placeItems: "center",
        backgroundColor: "#fff",
        color: "rgb(138, 147, 155)"
      },
      children: /*#__PURE__*/jsxs("div", {
        style: {
          display: "flex",
          flexDirection: "column",
          gap: "8px",
          alignItems: "center",
          flexWrap: "nowrap"
        },
        children: [/*#__PURE__*/jsx(CarbonDocumentUnknown, {
          style: {
            maxWidth: "128px",
            minWidth: "48px",
            width: "50%",
            aspectRatio: "1"
          }
        }), /*#__PURE__*/jsx("a", {
          rel: "noopener noreferrer",
          style: {
            textDecoration: "underline",
            color: "rgb(138, 147, 155)"
          },
          href: src !== null && src !== void 0 ? src : undefined,
          target: "_blank",
          ref: ref,
          children: alt || "File"
        })]
      })
    })
  }));
});
/**
 * This component can be used to render any media type, including image, audio, video, and html files.
 * Its convenient for rendering NFT media files, as these can be a variety of different types.
 * The component falls back to a external link if the media type is not supported.
 *
 * Props: {@link MediaRendererProps}
 *
 * @example
 * We can take a video file hosted on IPFS and render it using this component as follows
 * ```jsx
 * const Component = () => {
 *   return <MediaRenderer
 *     src="ipfs://Qmb9ZV5yznE4C4YvyJe8DVFv1LSVkebdekY6HjLVaKmHZi"
 *     alt="A mp4 video"
 *   />
 * }
 * ```
 *
 * You can try switching out the `src` prop to different types of URLs and media types to explore the possibilities.
 */

var MediaRenderer = /*#__PURE__*/React.forwardRef(function (_ref6, ref) {
  _ref6.children;
      var src = _ref6.src,
      poster = _ref6.poster,
      alt = _ref6.alt,
      _ref6$requireInteract = _ref6.requireInteraction,
      requireInteraction = _ref6$requireInteract === void 0 ? false : _ref6$requireInteract,
      style = _ref6.style,
      restProps = _objectWithoutProperties(_ref6, _excluded5);

  var mergedStyle = _objectSpread2({
    objectFit: "contain"
  }, style);

  var videoOrImageSrc = useResolvedMediaType(src !== null && src !== void 0 ? src : undefined);
  var possiblePosterSrc = useResolvedMediaType(poster !== null && poster !== void 0 ? poster : undefined);

  if (!videoOrImageSrc.mimeType) {
    return /*#__PURE__*/jsx("img", _objectSpread2(_objectSpread2({
      style: mergedStyle
    }, restProps), {}, {
      ref: ref
    }));
  } else if (videoOrImageSrc.mimeType === "text/html") {
    return /*#__PURE__*/jsx(IframePlayer, _objectSpread2({
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction: requireInteraction
    }, restProps));
  } else if (shouldRenderVideoTag(videoOrImageSrc.mimeType)) {
    return /*#__PURE__*/jsx(VideoPlayer, _objectSpread2({
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction: requireInteraction
    }, restProps));
  } else if (shouldRenderAudioTag(videoOrImageSrc.mimeType)) {
    return /*#__PURE__*/jsx(AudioPlayer, _objectSpread2({
      style: mergedStyle,
      src: videoOrImageSrc.url,
      poster: possiblePosterSrc.url,
      requireInteraction: requireInteraction
    }, restProps));
  } else if (videoOrImageSrc.mimeType.startsWith("image/")) {
    return /*#__PURE__*/jsx("img", _objectSpread2({
      style: mergedStyle,
      src: videoOrImageSrc.url,
      alt: alt,
      ref: ref
    }, restProps));
  }

  return /*#__PURE__*/jsx(LinkPlayer, _objectSpread2({
    style: mergedStyle,
    src: videoOrImageSrc.url,
    alt: alt,
    ref: ref
  }, restProps));
});

/**
 * @param uri - the uri to resolve (can be a url or a ipfs://\<cid\>)
 * @returns the fully resolved url + mime type of the media
 *
 * @example
 * Usage with fully formed url:
 * ```jsx
 * const Component = () => {
 *   const resolved = useResolvedMediaType("https://example.com/video.mp4");
 *   console.log("mime type", resolved.data.mimeType);
 *   console.log("url", resolved.data.url);
 *   return null;
 * }
 * ```
 *
 * Usage with ipfs cid:
 * ```jsx
 * const Component = () => {
 *   const resolved = useResolvedMediaType("ipfs://QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvsd");
 *   console.log("mime type", resolved.data.mimeType);
 *   console.log("url", resolved.data.url);
 *   return null;
 * }
 * ```
 */
function useResolvedMediaType(uri) {
  var resolvedUrl = useMemo(function () {
    return resolveIpfsUri(uri);
  }, [uri]);
  var resolvedMimType = useQuery(["mime-type", resolvedUrl], function () {
    return resolveMimeType(resolvedUrl);
  }, {
    enabled: !!resolvedUrl
  });
  return {
    url: resolvedUrl,
    mimeType: resolvedMimType.data
  };
}

var _excluded$6 = ["metadata"];

/**
 *
 * @example
 * ```jsx
 * import { ThirdwebNftMedia, useNFTCollection, useNFT } from "@thirdweb-dev/react";
 * export default function NFTCollectionRender() {
 *   const contract = useNFTCollection(<your-contract-address>);
 *   const { data: nft, isLoading } = useNFT(contract, 0);
 *
 *   return (
 *     <div>
 *       {!isLoading && nft ? (
 *         <ThirdwebNftMedia metadata={nft.metadata} />
 *       ) : (
 *         <p>Loading...</p>
 *       )}
 *     </div>
 *   );
 * }
 * ```
 *
 * Use this to get the primary sales recipient of your {@link SmartContract}
 * @param contract - an instance of a {@link SmartContract}
 * @returns the wallet address of the primary sales recipient
 * @beta
 */
var ThirdwebNftMedia = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var metadata = _ref.metadata,
      props = _objectWithoutProperties(_ref, _excluded$6);

  return /*#__PURE__*/jsx(MediaRenderer, _objectSpread2({
    src: metadata.animation_url || metadata.image,
    poster: metadata.image,
    alt: metadata.name,
    ref: ref
  }, props));
});

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function shortenString(str, extraShort) {
  return "".concat(str.substring(0, extraShort ? 4 : 6), "...").concat(str.substring(str.length - (extraShort ? 3 : 4)));
}
function shortenAddress(address, extraShort) {
  try {
    var formattedAddress = utils.getAddress(address);
    return shortenString(formattedAddress, extraShort);
  } catch (_unused) {
    return address;
  }
}
function shortenIfAddress(address, extraShort) {
  if (typeof address === "string" && address.length > 0) {
    return shortenAddress(address, extraShort);
  }

  return address || "";
}

var _excluded$5 = ["timeout"];

/**
 * React hook to copy content to clipboard
 *
 */
function useClipboard(text) {
  var optionsOrTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      hasCopied = _useState2[0],
      setHasCopied = _useState2[1];

  var _ref = typeof optionsOrTimeout === "number" ? {
    timeout: optionsOrTimeout
  } : optionsOrTimeout,
      _ref$timeout = _ref.timeout,
      timeout = _ref$timeout === void 0 ? 1500 : _ref$timeout,
      copyOptions = _objectWithoutProperties(_ref, _excluded$5);

  var onCopy = useCallback(function () {
    var didCopy = copy(text, copyOptions);
    setHasCopied(didCopy);
  }, [text, copyOptions]);
  useEffect(function () {
    var timeoutId = null;

    if (hasCopied) {
      timeoutId = window.setTimeout(function () {
        setHasCopied(false);
      }, timeout);
    }

    return function () {
      if (timeoutId) {
        window.clearTimeout(timeoutId);
      }
    };
  }, [timeout, hasCopied]);
  return {
    value: text,
    onCopy: onCopy,
    hasCopied: hasCopied
  };
}

function useIsMounted() {
  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isMounted = _useState2[0],
      setIsMounted = _useState2[1];

  useEffect(function () {
    setIsMounted(true);
  });
  return isMounted;
}

function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }

  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

var _templateObject$6;
var Box = styled.div(_templateObject$6 || (_templateObject$6 = _taggedTemplateLiteral([""])));

var _templateObject$5;
var spin = keyframes({
  "0%": {
    transform: "rotate(0deg)"
  },
  "100%": {
    transform: "rotate(360deg)"
  }
});
var Spinner = styled.div(_templateObject$5 || (_templateObject$5 = _taggedTemplateLiteral(["\n  display: inline-block;\n  border-top: 2px solid currentcolor;\n  border-right: 2px solid currentcolor;\n  border-bottom-style: solid;\n  border-left-style: solid;\n  border-radius: 99999px;\n  border-bottom-width: 2px;\n  border-left-width: 2px;\n  border-bottom-color: transparent;\n  border-left-color: transparent;\n  animation: 0.45s linear 0s infinite normal none running ", ";\n  width: 0.75em;\n  height: 0.75em;\n  flex-shrink: 0;\n"])), spin);

var _excluded$4 = ["children", "variant", "rightElement", "leftElement", "isLoading", "isDisabled", "disabled"];

var _templateObject$4, _templateObject2, _templateObject3;
var BaseButton = styled.button(_templateObject$4 || (_templateObject$4 = _taggedTemplateLiteral(["\n  position: relative;\n  border-radius: 0.5em;\n  padding: 0.75em 1.25em;\n  padding-right: ", ";\n  padding-left: ", ";\n  font-size: 1em;\n  font-weight: 600;\n  letter-spacing: 0.5px;\n  display: flex;\n  gap: 0.5em;\n  align-items: center;\n  color: ", ";\n  border: 2px solid\n    ", ";\n  &:hover {\n    cursor: pointer;\n  }\n  &:disabled {\n    cursor: not-allowed;\n  }\n  &:focus {\n    outline: 2px solid ", ";\n    outline-offset: 1px;\n  }\n"])), function (props) {
  return props.hasRightElement ? "0.75em" : "1.25em";
}, function (props) {
  return props.hasLeftElement ? "0.75em" : "1.25em";
}, function (props) {
  return computeTextColorBasedOnBackground(props.theme.colors.accent);
}, function (props) {
  return computeHoverColor(props.theme.colors.accent);
}, function (props) {
  return props.theme.colors.accent;
});

function computeHoverColor(c) {
  var col = color(c);

  if (col.hex() === "#000000") {
    return "#262627";
  }

  if (col.luminosity() < 0.2) {
    return col.lighten(0.1).hex();
  }

  return col.darken(0.1).hex();
}

function computeDisabledColor(c) {
  var col = color(c);

  if (col.hex() === "#000000") {
    return "#262627";
  }

  if (col.luminosity() < 0.2) {
    return col.lighten(0.5).hex();
  }

  return col.darken(0.5).hex();
}

function computeTextColorBasedOnBackground(c) {
  var col = color(c);

  if (col.isDark()) {
    return "#fff";
  }

  return "#000";
}

var SolidButton = styled(BaseButton)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n  background: ", ";\n  &:hover {\n    background: ", ";\n    border-color: ", ";\n  }\n  &:disabled {\n    background: ", ";\n    border-color: ", ";\n    color: ", ";\n  }\n"])), function (props) {
  return props.theme.colors.accent;
}, function (props) {
  return computeHoverColor(props.theme.colors.accent);
}, function (props) {
  return computeHoverColor(props.theme.colors.accent);
}, function (props) {
  return computeDisabledColor(props.theme.colors.accent);
}, function (props) {
  return computeDisabledColor(props.theme.colors.accent);
}, function (props) {
  return computeTextColorBasedOnBackground(computeDisabledColor(props.theme.colors.accent));
});
var OutlineButton = styled(BaseButton)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n  background: transparent;\n  &:hover {\n    background: ", ";\n  }\n"])), function (props) {
  return color(props.theme.colors.background).alpha(0.5).hexa();
});
var Button = function Button(_ref) {
  var children = _ref.children,
      variant = _ref.variant,
      rightElement = _ref.rightElement,
      leftElement = _ref.leftElement,
      isLoading = _ref.isLoading,
      isDisabled = _ref.isDisabled,
      disabled = _ref.disabled,
      restProps = _objectWithoutProperties(_ref, _excluded$4);

  var Btn = variant === "outline" ? OutlineButton : SolidButton;
  return /*#__PURE__*/jsxs(Btn, _objectSpread2(_objectSpread2({}, restProps), {}, {
    disabled: isDisabled || disabled || isLoading,
    hasRightElement: !!rightElement,
    hasLeftElement: !!leftElement,
    children: [isLoading ? /*#__PURE__*/jsx(Spinner, {
      style: {
        position: "absolute",
        left: "calc(50% - 0.75em / 2)"
      }
    }) : null, /*#__PURE__*/jsxs("span", {
      style: {
        opacity: isLoading ? 0 : 1,
        display: "inherit",
        gap: "inherit",
        alignItems: "inherit"
      },
      children: [leftElement, children, rightElement]
    })]
  }));
};

var chainLogos = {
  ethereum: {
    svgProps: {
      viewBox: "0 0 28 28",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none"
    },
    paths: /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx("path", {
        fill: "#25292E",
        fillRule: "evenodd",
        d: "M14 28a14 14 0 1 0 0-28 14 14 0 0 0 0 28Z",
        clipRule: "evenodd"
      }), /*#__PURE__*/jsx("path", {
        fill: "url(#a)",
        fillOpacity: ".3",
        fillRule: "evenodd",
        d: "M14 28a14 14 0 1 0 0-28 14 14 0 0 0 0 28Z",
        clipRule: "evenodd"
      }), /*#__PURE__*/jsx("path", {
        fill: "url(#b)",
        d: "M8.19 14.77 14 18.21l5.8-3.44-5.8 8.19-5.81-8.19Z"
      }), /*#__PURE__*/jsx("path", {
        fill: "#fff",
        d: "m14 16.93-5.81-3.44L14 4.34l5.81 9.15L14 16.93Z"
      }), /*#__PURE__*/jsxs("defs", {
        children: [/*#__PURE__*/jsxs("linearGradient", {
          id: "a",
          x1: "0",
          x2: "14",
          y1: "0",
          y2: "28",
          gradientUnits: "userSpaceOnUse",
          children: [/*#__PURE__*/jsx("stop", {
            stopColor: "#fff"
          }), /*#__PURE__*/jsx("stop", {
            offset: "1",
            stopColor: "#fff",
            stopOpacity: "0"
          })]
        }), /*#__PURE__*/jsxs("linearGradient", {
          id: "b",
          x1: "14",
          x2: "14",
          y1: "14.77",
          y2: "22.96",
          gradientUnits: "userSpaceOnUse",
          children: [/*#__PURE__*/jsx("stop", {
            stopColor: "#fff"
          }), /*#__PURE__*/jsx("stop", {
            offset: "1",
            stopColor: "#fff",
            stopOpacity: ".9"
          })]
        })]
      })]
    })
  },
  arbitrum: {
    svgProps: {
      viewBox: "0 0 28 28",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none"
    },
    paths: /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx("rect", {
        width: "26.6",
        height: "26.6",
        x: ".7",
        y: ".7",
        fill: "#2D374B",
        stroke: "#96BEDC",
        strokeWidth: "1.4",
        rx: "13.3"
      }), /*#__PURE__*/jsx("mask", {
        id: "a",
        width: "28",
        height: "28",
        x: "0",
        y: "0",
        maskUnits: "userSpaceOnUse",
        style: {
          maskType: "alpha"
        },
        children: /*#__PURE__*/jsx("rect", {
          width: "28",
          height: "28",
          fill: "#C4C4C4",
          rx: "14"
        })
      }), /*#__PURE__*/jsxs("g", {
        mask: "url(#a)",
        children: [/*#__PURE__*/jsx("path", {
          fill: "#28A0F0",
          d: "m14.0861 18.6041 6.5014 10.2239 4.0057-2.3213-7.86-12.3943-2.6471 4.4917Zm13.0744 3.4692-.003-1.8599-7.3064-11.407-2.3087 3.9173 7.091 11.4303 2.172-1.2586a.9628.9628 0 0 0 .3555-.7009l-.0004-.1212Z"
        }), /*#__PURE__*/jsx("rect", {
          width: "25.9",
          height: "25.9",
          x: "1.05",
          y: "1.05",
          fill: "url(#b)",
          fillOpacity: ".3",
          stroke: "#96BEDC",
          strokeWidth: "2.1",
          rx: "12.95"
        }), /*#__PURE__*/jsx("path", {
          fill: "#fff",
          d: "m.3634 28.2207-3.07-1.7674-.234-.8333L7.7461 9.0194c.7298-1.1913 2.3197-1.575 3.7957-1.5541l1.7323.0457L.3634 28.2207ZM19.1655 7.511l-4.5653.0166L2.24 27.9533l3.6103 2.0788.9818-1.6652L19.1655 7.511Z"
        })]
      }), /*#__PURE__*/jsx("defs", {
        children: /*#__PURE__*/jsxs("linearGradient", {
          id: "b",
          x1: "0",
          x2: "14",
          y1: "0",
          y2: "28",
          gradientUnits: "userSpaceOnUse",
          children: [/*#__PURE__*/jsx("stop", {
            stopColor: "#fff"
          }), /*#__PURE__*/jsx("stop", {
            offset: "1",
            stopColor: "#fff",
            stopOpacity: "0"
          })]
        })
      })]
    })
  },
  avalanche: {
    svgProps: {
      viewBox: "0 0 28 28",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none"
    },
    paths: /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx("path", {
        fill: "#fff",
        d: "M23 5H5v18h18V5Z"
      }), /*#__PURE__*/jsx("path", {
        fill: "#E84142",
        fillRule: "evenodd",
        d: "M14 28c-7.513.008-14-6.487-14-14C0 6.196 6.043-.008 14 0c7.95.008 14 6.196 14 14 0 7.505-6.495 13.992-14 14Zm-3.971-7.436H7.315c-.57 0-.851 0-1.023-.11a.69.69 0 0 1-.313-.54c-.01-.202.13-.45.412-.944l6.7-11.809c.285-.501.43-.752.612-.845.195-.1.429-.1.625 0 .182.093.326.344.611.845l1.377 2.404.007.013c.308.538.464.81.533 1.097a2.04 2.04 0 0 1 0 .954c-.07.289-.224.564-.536 1.11l-3.52 6.22-.009.017c-.31.542-.467.817-.684 1.024a2.048 2.048 0 0 1-.835.485c-.285.079-.604.079-1.243.079Zm6.852 0h3.888c.574 0 .862 0 1.034-.113a.687.687 0 0 0 .313-.543c.01-.196-.128-.434-.398-.9a8.198 8.198 0 0 1-.028-.048l-1.948-3.332-.022-.037c-.274-.463-.412-.697-.59-.787a.684.684 0 0 0-.621 0c-.179.093-.323.337-.608.828l-1.94 3.331-.007.012c-.284.49-.426.735-.416.936.014.22.127.423.313.543.168.11.456.11 1.03.11Z",
        clipRule: "evenodd"
      })]
    })
  },
  optimism: {
    svgProps: {
      viewBox: "0 0 28 28",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none"
    },
    paths: /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx("rect", {
        width: "28",
        height: "28",
        fill: "#FF3131",
        rx: "14"
      }), /*#__PURE__*/jsx("rect", {
        width: "28",
        height: "28",
        fill: "url(#a)",
        fillOpacity: ".3",
        rx: "14"
      }), /*#__PURE__*/jsx("path", {
        fill: "#fff",
        d: "M9.22 18.35c2.7 0 4.86-2.2 4.86-5.38 0-2.19-1.47-3.8-3.98-3.8-2.72 0-4.85 2.2-4.85 5.38 0 2.2 1.5 3.8 3.97 3.8Zm.83-7.35c1.06 0 1.74.81 1.74 2.1 0 1.9-1.11 3.42-2.51 3.42-1.06 0-1.74-.82-1.74-2.1 0-1.89 1.11-3.42 2.5-3.42Zm6.38-1.68-1.88 8.88h2.26l.55-2.6h1.47c2.43 0 4.01-1.38 4.01-3.6 0-1.61-1.17-2.68-3.1-2.68h-3.3Zm1.9 1.74h.94c.83 0 1.3.38 1.3 1.14 0 1-.68 1.7-1.74 1.7h-1.11l.6-2.84Z"
      }), /*#__PURE__*/jsx("defs", {
        children: /*#__PURE__*/jsxs("linearGradient", {
          id: "a",
          x1: "0",
          x2: "14",
          y1: "0",
          y2: "28",
          gradientUnits: "userSpaceOnUse",
          children: [/*#__PURE__*/jsx("stop", {
            stopColor: "#fff"
          }), /*#__PURE__*/jsx("stop", {
            offset: "1",
            stopColor: "#fff",
            stopOpacity: "0"
          })]
        })
      })]
    })
  },
  polygon: {
    svgProps: {
      viewBox: "0 0 28 28",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none"
    },
    paths: /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx("rect", {
        width: "28",
        height: "28",
        fill: "#8247E5",
        rx: "14"
      }), /*#__PURE__*/jsx("rect", {
        width: "28",
        height: "28",
        fill: "url(#a)",
        fillOpacity: ".3",
        rx: "14"
      }), /*#__PURE__*/jsx("path", {
        fill: "#fff",
        d: "M18.28 10.92a1.06 1.06 0 0 0-1.06 0l-2.41 1.42-1.65.93-2.41 1.43c-.31.19-.72.19-1.06 0l-1.92-1.12a1.07 1.07 0 0 1-.53-.9v-2.2a1 1 0 0 1 .53-.9l1.9-1.08c.3-.18.7-.18 1.04 0l1.9 1.09c.3.18.52.52.52.9v1.42l1.64-.96V9.52a1 1 0 0 0-.52-.9l-3.5-2.04a1.06 1.06 0 0 0-1.06 0L6.13 8.63a1 1 0 0 0-.53.9v4.12a1 1 0 0 0 .53.9l3.56 2.04c.31.19.71.19 1.06 0l2.41-1.4 1.65-.95 2.41-1.4c.31-.19.72-.19 1.06 0l1.89 1.09c.3.18.53.52.53.9v2.2a1 1 0 0 1-.53.9l-1.9 1.11c-.3.19-.7.19-1.05 0l-1.89-1.08a1.07 1.07 0 0 1-.52-.9v-1.43l-1.65.96v1.43a1 1 0 0 0 .53.9l3.56 2.04c.31.19.72.19 1.06 0l3.56-2.04c.31-.19.53-.53.53-.9v-4.13a1 1 0 0 0-.53-.9l-3.6-2.07Z"
      }), /*#__PURE__*/jsx("defs", {
        children: /*#__PURE__*/jsxs("linearGradient", {
          id: "a",
          x1: "0",
          x2: "14",
          y1: "0",
          y2: "28",
          gradientUnits: "userSpaceOnUse",
          children: [/*#__PURE__*/jsx("stop", {
            stopColor: "#fff"
          }), /*#__PURE__*/jsx("stop", {
            offset: "1",
            stopColor: "#fff",
            stopOpacity: "0"
          })]
        })
      })]
    })
  },
  fantom: {
    svgProps: {
      viewBox: "0 0 32 32",
      xmlns: "http://www.w3.org/2000/svg"
    },
    paths: /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsxs("defs", {
        children: [/*#__PURE__*/jsx("style", {
          children: ".cls-1{fill:#fff;fill-rule:evenodd}"
        }), /*#__PURE__*/jsx("mask", {
          id: "mask",
          width: 93.1,
          height: 20,
          x: 10,
          y: 6,
          maskUnits: "userSpaceOnUse",
          children: /*#__PURE__*/jsx("path", {
            id: "a",
            d: "M10 6h93.1v20H10Z",
            className: "cls-1"
          })
        })]
      }), /*#__PURE__*/jsx("g", {
        id: "Layer_2",
        "data-name": "Layer 2",
        children: /*#__PURE__*/jsxs("g", {
          id: "Layer_1-2",
          "data-name": "Layer 1",
          children: [/*#__PURE__*/jsx("circle", {
            cx: 16,
            cy: 16,
            r: 16,
            fill: "#13b5ec"
          }), /*#__PURE__*/jsx("path", {
            d: "m17.2 12.9 3.6-2.1V15Zm3.6 9L16 24.7l-4.8-2.8V17l4.8 2.8 4.8-2.8Zm-9.6-11.1 3.6 2.1-3.6 2.1Zm5.4 3.1 3.6 2.1-3.6 2.1Zm-1.2 4.2L11.8 16l3.6-2.1Zm4.8-8.3L16 12.2l-4.2-2.4L16 7.3ZM10 9.4v13.1l6 3.4 6-3.4V9.4L16 6Z",
            className: "cls-1"
          })]
        })
      })]
    })
  }
};

var CoinbaseWalletIcon = {
  svgProps: {
    viewBox: "0 0 28 28",
    width: "28",
    height: "28",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  },
  paths: /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx("rect", {
      width: "28",
      height: "28",
      fill: "#2C5FF6"
    }), /*#__PURE__*/jsx("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M14 23.8C19.4124 23.8 23.8 19.4124 23.8 14C23.8 8.58761 19.4124 4.2 14 4.2C8.58761 4.2 4.2 8.58761 4.2 14C4.2 19.4124 8.58761 23.8 14 23.8ZM11.55 10.8C11.1358 10.8 10.8 11.1358 10.8 11.55V16.45C10.8 16.8642 11.1358 17.2 11.55 17.2H16.45C16.8642 17.2 17.2 16.8642 17.2 16.45V11.55C17.2 11.1358 16.8642 10.8 16.45 10.8H11.55Z",
      fill: "white"
    })]
  })
};

var MetamaskIcon = {
  svgProps: {
    viewBox: "0 0 28 28",
    width: "28",
    height: "28",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  },
  paths: /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx("rect", {
      width: "28",
      height: "28",
      fill: "white"
    }), /*#__PURE__*/jsx("path", {
      d: "M24.0891 3.1199L15.3446 9.61456L16.9617 5.7828L24.0891 3.1199Z",
      fill: "#E2761B",
      stroke: "#E2761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M3.90207 3.1199L12.5763 9.67608L11.0383 5.7828L3.90207 3.1199Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M20.9429 18.1745L18.6139 21.7426L23.597 23.1136L25.0295 18.2536L20.9429 18.1745Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M2.97929 18.2536L4.40301 23.1136L9.38607 21.7426L7.05713 18.1745L2.97929 18.2536Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M9.10483 12.1456L7.71626 14.2461L12.6642 14.4658L12.4884 9.14877L9.10483 12.1456Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M18.8864 12.1456L15.4589 9.08725L15.3446 14.4658L20.2837 14.2461L18.8864 12.1456Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M9.38606 21.7426L12.3566 20.2925L9.79033 18.2888L9.38606 21.7426Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M15.6347 20.2925L18.6139 21.7426L18.2009 18.2888L15.6347 20.2925Z",
      fill: "#E4761B",
      stroke: "#E4761B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M18.6139 21.7426L15.6347 20.2925L15.8719 22.2348L15.8456 23.0521L18.6139 21.7426Z",
      fill: "#D7C1B3",
      stroke: "#D7C1B3",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M9.38606 21.7426L12.1544 23.0521L12.1368 22.2348L12.3566 20.2925L9.38606 21.7426Z",
      fill: "#D7C1B3",
      stroke: "#D7C1B3",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M12.1984 17.0056L9.72002 16.2762L11.4689 15.4765L12.1984 17.0056Z",
      fill: "#233447",
      stroke: "#233447",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M15.7928 17.0056L16.5223 15.4765L18.28 16.2762L15.7928 17.0056Z",
      fill: "#233447",
      stroke: "#233447",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M9.38606 21.7426L9.80791 18.1745L7.05712 18.2536L9.38606 21.7426Z",
      fill: "#CD6116",
      stroke: "#CD6116",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M18.1921 18.1745L18.6139 21.7426L20.9429 18.2536L18.1921 18.1745Z",
      fill: "#CD6116",
      stroke: "#CD6116",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M20.2837 14.2461L15.3446 14.4658L15.8016 17.0057L16.5311 15.4765L18.2888 16.2762L20.2837 14.2461Z",
      fill: "#CD6116",
      stroke: "#CD6116",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M9.72002 16.2762L11.4777 15.4765L12.1984 17.0057L12.6642 14.4658L7.71626 14.2461L9.72002 16.2762Z",
      fill: "#CD6116",
      stroke: "#CD6116",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M7.71626 14.2461L9.79033 18.2888L9.72002 16.2762L7.71626 14.2461Z",
      fill: "#E4751F",
      stroke: "#E4751F",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M18.2888 16.2762L18.2009 18.2888L20.2837 14.2461L18.2888 16.2762Z",
      fill: "#E4751F",
      stroke: "#E4751F",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M12.6642 14.4658L12.1984 17.0057L12.7784 20.0025L12.9102 16.0565L12.6642 14.4658Z",
      fill: "#E4751F",
      stroke: "#E4751F",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M15.3446 14.4658L15.1073 16.0477L15.2128 20.0025L15.8016 17.0057L15.3446 14.4658Z",
      fill: "#E4751F",
      stroke: "#E4751F",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M15.8016 17.0056L15.2128 20.0025L15.6347 20.2925L18.2009 18.2888L18.2888 16.2762L15.8016 17.0056Z",
      fill: "#F6851B",
      stroke: "#F6851B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M9.72002 16.2762L9.79033 18.2888L12.3566 20.2925L12.7784 20.0025L12.1984 17.0056L9.72002 16.2762Z",
      fill: "#F6851B",
      stroke: "#F6851B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M15.8456 23.0521L15.8719 22.2348L15.6522 22.0414H12.339L12.1368 22.2348L12.1544 23.0521L9.38606 21.7426L10.3528 22.5336L12.3126 23.8958H15.6786L17.6472 22.5336L18.6139 21.7426L15.8456 23.0521Z",
      fill: "#C0AD9E",
      stroke: "#C0AD9E",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M15.6347 20.2925L15.2128 20.0025H12.7784L12.3566 20.2925L12.1368 22.2348L12.339 22.0414H15.6522L15.8719 22.2348L15.6347 20.2925Z",
      fill: "#161616",
      stroke: "#161616",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M24.4583 10.0364L25.2053 6.45072L24.0891 3.1199L15.6347 9.39485L18.8864 12.1456L23.4827 13.4903L24.5022 12.3038L24.0628 11.9874L24.7658 11.3459L24.221 10.924L24.924 10.3879L24.4583 10.0364Z",
      fill: "#763D16",
      stroke: "#763D16",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M2.79472 6.45072L3.54174 10.0364L3.06717 10.3879L3.77024 10.924L3.23415 11.3459L3.93722 11.9874L3.4978 12.3038L4.50847 13.4903L9.10483 12.1456L12.3566 9.39485L3.90207 3.1199L2.79472 6.45072Z",
      fill: "#763D16",
      stroke: "#763D16",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M23.4827 13.4903L18.8864 12.1456L20.2837 14.2461L18.2009 18.2888L20.9429 18.2536H25.0295L23.4827 13.4903Z",
      fill: "#F6851B",
      stroke: "#F6851B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M9.10484 12.1456L4.50848 13.4903L2.97929 18.2536H7.05713L9.79033 18.2888L7.71626 14.2461L9.10484 12.1456Z",
      fill: "#F6851B",
      stroke: "#F6851B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }), /*#__PURE__*/jsx("path", {
      d: "M15.3446 14.4658L15.6347 9.39485L16.9705 5.7828H11.0383L12.3566 9.39485L12.6642 14.4658L12.7696 16.0653L12.7784 20.0025H15.2128L15.2304 16.0653L15.3446 14.4658Z",
      fill: "#F6851B",
      stroke: "#F6851B",
      strokeWidth: "0.0878845",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    })]
  })
};

var WalletConnectIcon = {
  svgProps: {
    viewBox: "0 0 28 28",
    width: "28",
    height: "28",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  },
  paths: /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx("rect", {
      width: "28",
      height: "28",
      fill: "#3B99FC"
    }), /*#__PURE__*/jsx("path", {
      d: "M8.38969 10.3739C11.4882 7.27538 16.5118 7.27538 19.6103 10.3739L19.9832 10.7468C20.1382 10.9017 20.1382 11.1529 19.9832 11.3078L18.7076 12.5835C18.6301 12.6609 18.5045 12.6609 18.4271 12.5835L17.9139 12.0703C15.7523 9.9087 12.2477 9.9087 10.0861 12.0703L9.53655 12.6198C9.45909 12.6973 9.3335 12.6973 9.25604 12.6198L7.98039 11.3442C7.82547 11.1893 7.82547 10.9381 7.98039 10.7832L8.38969 10.3739ZM22.2485 13.012L23.3838 14.1474C23.5387 14.3023 23.5387 14.5535 23.3838 14.7084L18.2645 19.8277C18.1096 19.9827 17.8584 19.9827 17.7035 19.8277C17.7035 19.8277 17.7035 19.8277 17.7035 19.8277L14.0702 16.1944C14.0314 16.1557 13.9686 16.1557 13.9299 16.1944C13.9299 16.1944 13.9299 16.1944 13.9299 16.1944L10.2966 19.8277C10.1417 19.9827 9.89053 19.9827 9.73561 19.8278C9.7356 19.8278 9.7356 19.8277 9.7356 19.8277L4.61619 14.7083C4.46127 14.5534 4.46127 14.3022 4.61619 14.1473L5.75152 13.012C5.90645 12.857 6.15763 12.857 6.31255 13.012L9.94595 16.6454C9.98468 16.6841 10.0475 16.6841 10.0862 16.6454C10.0862 16.6454 10.0862 16.6454 10.0862 16.6454L13.7194 13.012C13.8743 12.857 14.1255 12.857 14.2805 13.012C14.2805 13.012 14.2805 13.012 14.2805 13.012L17.9139 16.6454C17.9526 16.6841 18.0154 16.6841 18.0541 16.6454L21.6874 13.012C21.8424 12.8571 22.0936 12.8571 22.2485 13.012Z",
      fill: "white"
    })]
  })
};

var _excluded$3 = ["name"];

var _templateObject$3;
var StyledSvg = styled.svg(_templateObject$3 || (_templateObject$3 = _taggedTemplateLiteral(["\n  border-radius: 0.25em;\n  flex-shrink: 0;\n  ", "\n"])), function (props) {
  return props.boxSize ? "width: ".concat(props.boxSize, ";\n    height: ").concat(props.boxSize, ";") : "";
});

var iconMap = _objectSpread2({
  metamask: MetamaskIcon,
  walletConnect: WalletConnectIcon,
  coinbaseWallet: CoinbaseWalletIcon
}, chainLogos);

var Icon = function Icon(_ref) {
  var name = _ref.name,
      props = _objectWithoutProperties(_ref, _excluded$3);

  var icon = iconMap[name];
  return /*#__PURE__*/jsx(StyledSvg, _objectSpread2(_objectSpread2(_objectSpread2({}, icon.svgProps), props), {}, {
    children: icon.paths
  }));
};

var _excluded$2 = ["children", "leftElement", "rightElement", "isSelectable", "onClick"];

var _templateObject$2;
var MenuItemBase = styled.li(_templateObject$2 || (_templateObject$2 = _taggedTemplateLiteral(["\n  display: flex;\n  padding: 0.75em 1em;\n  align-items: center;\n  gap: 0.5em;\n  font-size: 1em;\n\n  ", "\n\n  > svg {\n    flex-shrink: 0;\n  }\n"])), function (props) {
  return props.isSelectable ? "&:hover,\n  &[data-focus] {\n    cursor: pointer;\n    background: ".concat(color(props.theme.colors.text).alpha(0.15).hexa(), ";\n  }") : "";
});
var MenuItem = function MenuItem(_ref) {
  var children = _ref.children,
      leftElement = _ref.leftElement,
      rightElement = _ref.rightElement,
      _ref$isSelectable = _ref.isSelectable,
      isSelectable = _ref$isSelectable === void 0 ? true : _ref$isSelectable,
      onClick = _ref.onClick,
      restProps = _objectWithoutProperties(_ref, _excluded$2);

  return /*#__PURE__*/jsxs(MenuItemBase, _objectSpread2(_objectSpread2({}, restProps), {}, {
    onClick: isSelectable ? onClick : undefined,
    isSelectable: isSelectable,
    children: [leftElement, children, rightElement]
  }));
};

var _templateObject$1;
var Menu = styled.ul(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral(["\n  padding: 0;\n  margin: 0;\n  background: ", ";\n  color: ", ";\n  outline-color: ", ";\n  outline-style: solid;\n  outline-offset: 0px;\n  list-style: none;\n  border-radius: 0.5em;\n  overflow: hidden;\n"])), function (props) {
  return props.theme.colors.background;
}, function (props) {
  return props.theme.colors.text;
}, function (props) {
  return props.theme.colors.accent;
});

var lightModeTheme = {
  colors: {
    accent: "#fff",
    background: "#fff",
    text: "#000"
  }
};
var darkModeTheme = {
  colors: {
    accent: "#000",
    background: "#000",
    text: "#fff"
  }
};
var fontFamily = "SFRounded, ui-rounded, \"SF Pro Rounded\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica,\nArial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"";

var ThemeProvider = function ThemeProvider(_ref) {
  var colorMode = _ref.colorMode,
      accentColor = _ref.accentColor,
      children = _ref.children;
  var theme = useMemo(function () {
    var t = colorMode === "light" ? lightModeTheme : darkModeTheme;
    return _objectSpread2(_objectSpread2({}, t), {}, {
      colors: _objectSpread2(_objectSpread2({}, t.colors), {}, {
        accent: accentColor || t.colors.accent
      })
    });
  }, [accentColor, colorMode]);
  return /*#__PURE__*/jsx(ThemeProvider$1, {
    theme: theme,
    children: /*#__PURE__*/jsx("span", {
      style: {
        fontFamily: fontFamily
      },
      children: children
    })
  });
};

var _templateObject;
var Select = styled.select(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  margin: -0.25em 0;\n  background: ", ";\n  color: ", ";\n  border: 1px solid\n    ", ";\n  border-radius: 0.25em;\n  padding: 0.25em;\n  width: 100%;\n  flex-shrink: 1;\n  font-size: 1em;\n  &:hover {\n    cursor: pointer;\n  }\n  &:focus {\n    outline: 2px solid ", ";\n  }\n  &:disabled {\n    cursor: not-allowed;\n  }\n"])), function (props) {
  return color(props.theme.colors.background).alpha(0.85).hexa();
}, function (props) {
  return props.theme.colors.text;
}, function (props) {
  return color(props.theme.colors.text).alpha(0.25).hexa();
}, function (props) {
  return props.theme.colors.accent;
});

var _excluded$1 = ["disabledChainIds"];
var SupportedNetworkSelect = function SupportedNetworkSelect(_ref) {
  var disabledChainIds = _ref.disabledChainIds,
      selectProps = _objectWithoutProperties(_ref, _excluded$1);

  var deprecatedNetworks = useMemo(function () {
    return SUPPORTED_CHAIN_IDS.map(function (supportedChain) {
      return getChainFromChainId(supportedChain);
    }).filter(function (n) {
      return n.id === ChainId$1.Rinkeby;
    });
  }, []);
  var testnets = useMemo(function () {
    return SUPPORTED_CHAIN_IDS.map(function (supportedChain) {
      return getChainFromChainId(supportedChain);
    }).filter(function (n) {
      return n.testnet && n.id !== ChainId$1.Rinkeby;
    });
  }, []);
  var mainnets = useMemo(function () {
    return SUPPORTED_CHAIN_IDS.map(function (supportedChain) {
      return getChainFromChainId(supportedChain);
    }).filter(function (n) {
      return !n.testnet;
    });
  }, []);
  return /*#__PURE__*/jsxs(Select, _objectSpread2(_objectSpread2({}, selectProps), {}, {
    children: [/*#__PURE__*/jsx("option", {
      disabled: true,
      value: -1,
      children: "Select Network"
    }), /*#__PURE__*/jsx("optgroup", {
      label: "Mainnets",
      children: mainnets.map(function (mn) {
        var _mn$nativeCurrency;

        return /*#__PURE__*/jsxs("option", {
          value: mn.id,
          disabled: disabledChainIds === null || disabledChainIds === void 0 ? void 0 : disabledChainIds.includes(mn.id),
          children: [mn.name, " (", (_mn$nativeCurrency = mn.nativeCurrency) === null || _mn$nativeCurrency === void 0 ? void 0 : _mn$nativeCurrency.symbol, ")"]
        }, mn.id);
      })
    }), /*#__PURE__*/jsx("optgroup", {
      label: "Testnets",
      children: testnets.map(function (tn) {
        var _tn$nativeCurrency;

        return /*#__PURE__*/jsxs("option", {
          value: tn.id,
          disabled: disabledChainIds === null || disabledChainIds === void 0 ? void 0 : disabledChainIds.includes(tn.id),
          children: [tn.name, " (", (_tn$nativeCurrency = tn.nativeCurrency) === null || _tn$nativeCurrency === void 0 ? void 0 : _tn$nativeCurrency.symbol, ")"]
        }, tn.id);
      })
    }), /*#__PURE__*/jsx("optgroup", {
      label: "Deprecated",
      children: deprecatedNetworks.map(function (tn) {
        var _tn$nativeCurrency2;

        return /*#__PURE__*/jsxs("option", {
          value: tn.id,
          disabled: disabledChainIds === null || disabledChainIds === void 0 ? void 0 : disabledChainIds.includes(tn.id),
          children: [tn.name, " (", (_tn$nativeCurrency2 = tn.nativeCurrency) === null || _tn$nativeCurrency2 === void 0 ? void 0 : _tn$nativeCurrency2.symbol, ")"]
        }, tn.id);
      })
    })]
  }));
};

var _chainIdToCurrencyMap;
var SUPPORTED_CONNECTORS = ["injected", "walletConnect", "coinbasewallet"];

function getIconForConnector(connector) {
  if (connector.name.toLowerCase().includes("coinbase")) {
    return /*#__PURE__*/jsx(Icon, {
      boxSize: "1.5em",
      name: "coinbaseWallet"
    });
  }

  if (connector.name.toLocaleLowerCase().includes("metamask")) {
    return /*#__PURE__*/jsx(Icon, {
      boxSize: "1.5em",
      name: "metamask"
    });
  }

  var id = connector.id;

  switch (id) {
    case "injected":
      return /*#__PURE__*/jsx(Icon, {
        boxSize: "1.5em",
        name: "metamask"
      });

    case "walletConnect":
      return /*#__PURE__*/jsx(Icon, {
        boxSize: "1.5em",
        name: "walletConnect"
      });

    case "coinbasewallet":
      return /*#__PURE__*/jsx(Icon, {
        boxSize: "1.5em",
        name: "coinbaseWallet"
      });

    default:
      throw new Error("unsupported connector");
  }
}

var connecting = false;
var switchingNetwork = false;
var chainIdToCurrencyMap = (_chainIdToCurrencyMap = {}, _defineProperty(_chainIdToCurrencyMap, ChainId$1.Mainnet, "ethereum"), _defineProperty(_chainIdToCurrencyMap, ChainId$1.Goerli, "ethereum"), _defineProperty(_chainIdToCurrencyMap, ChainId$1.Rinkeby, "ethereum"), _defineProperty(_chainIdToCurrencyMap, ChainId$1.Arbitrum, "arbitrum"), _defineProperty(_chainIdToCurrencyMap, ChainId$1.ArbitrumTestnet, "arbitrum"), _defineProperty(_chainIdToCurrencyMap, ChainId$1.Avalanche, "avalanche"), _defineProperty(_chainIdToCurrencyMap, ChainId$1.AvalancheFujiTestnet, "avalanche"), _defineProperty(_chainIdToCurrencyMap, ChainId$1.Fantom, "fantom"), _defineProperty(_chainIdToCurrencyMap, ChainId$1.FantomTestnet, "fantom"), _defineProperty(_chainIdToCurrencyMap, ChainId$1.Optimism, "optimism"), _defineProperty(_chainIdToCurrencyMap, ChainId$1.OptimismTestnet, "optimism"), _defineProperty(_chainIdToCurrencyMap, ChainId$1.Polygon, "polygon"), _defineProperty(_chainIdToCurrencyMap, ChainId$1.Mumbai, "polygon"), _chainIdToCurrencyMap);
/**
 * A component that allows the user to connect their wallet.
 *
 * The button has to be wrapped in a `ThirdwebProvider` in order to function.
 *
 * @example
 * ```javascript
 * import { ConnectWallet } from '@thirdweb-dev/react';
 *
 * const App = () => {
 *  return (
 *   <div>
 *     <ConnectWallet />
 *   </div>
 * )
 * }
 * ```
 *
 *
 * @beta
 */

var ConnectWallet = function ConnectWallet(_ref) {
  var _balanceQuery$data, _balanceQuery$data2;

  var themeProps = _extends({}, _ref);

  var id = useId();
  var isMounted = useIsMounted();
  var address = useAddress();
  var mountedAddress = useMemo(function () {
    return isMounted ? address : null;
  }, [address, isMounted]);

  var _useMachine = useMachine(menu.machine({
    id: id,
    closeOnSelect: true,
    positioning: {
      sameWidth: true
    }
  })),
      _useMachine2 = _slicedToArray(_useMachine, 2),
      state = _useMachine2[0],
      send = _useMachine2[1];

  var api = menu.connect(state, send, normalizeProps);

  var _useConnect = useConnect(),
      _useConnect2 = _slicedToArray(_useConnect, 2),
      _useConnect2$0$data = _useConnect2[0].data,
      connectors = _useConnect2$0$data.connectors,
      connector = _useConnect2$0$data.connector,
      connect = _useConnect2[1];

  var disconnect = useDisconnect({
    reconnectAfterGnosis: false
  });
  var supportedConnectors = connectors.filter(function (c) {
    return SUPPORTED_CONNECTORS.includes(c.id);
  });

  var _useNetwork = useNetwork(),
      _useNetwork2 = _slicedToArray(_useNetwork, 2),
      network = _useNetwork2[0],
      switchNetwork = _useNetwork2[1];

  var chainId = useChainId();
  var connectWithMetamask = useMetamask();
  var balanceQuery = useBalance();

  var _useClipboard = useClipboard(mountedAddress || ""),
      onCopy = _useClipboard.onCopy,
      hasCopied = _useClipboard.hasCopied;

  return /*#__PURE__*/jsx(ThemeProvider, _objectSpread2(_objectSpread2({}, themeProps), {}, {
    children: /*#__PURE__*/jsxs("div", {
      style: {
        position: "relative"
      },
      children: [/*#__PURE__*/jsx(Button, _objectSpread2(_objectSpread2({
        style: {
          height: "50px"
        }
      }, api.triggerProps), {}, {
        leftElement: mountedAddress && chainId && chainId in chainIdToCurrencyMap ? /*#__PURE__*/jsx(Icon, {
          boxSize: "1.5em",
          name: chainIdToCurrencyMap[chainId]
        }) : undefined,
        rightElement: /*#__PURE__*/jsxs(Fragment, {
          children: [connector && getIconForConnector(connector), /*#__PURE__*/jsx(FiChevronDown, {
            style: {
              transition: "transform 150ms ease",
              transform: "rotate(".concat(api.isOpen ? "-180deg" : "0deg", ")")
            }
          })]
        }),
        children: mountedAddress ? /*#__PURE__*/jsxs("span", {
          style: {
            display: "flex",
            flexDirection: "column",
            fontWeight: 400,
            alignItems: "flex-start",
            fontSize: "0.8em"
          },
          children: [/*#__PURE__*/jsx("span", {
            style: {
              whiteSpace: "nowrap",
              fontWeight: 500
            },
            children: balanceQuery.isLoading ? "Loading..." : /*#__PURE__*/jsxs(Fragment, {
              children: [(_balanceQuery$data = balanceQuery.data) === null || _balanceQuery$data === void 0 ? void 0 : _balanceQuery$data.displayValue.slice(0, 5), " ", (_balanceQuery$data2 = balanceQuery.data) === null || _balanceQuery$data2 === void 0 ? void 0 : _balanceQuery$data2.symbol]
            })
          }), /*#__PURE__*/jsx("span", {
            style: {
              fontSize: "0.9em"
            },
            children: shortenIfAddress(mountedAddress)
          })]
        }) : /*#__PURE__*/jsx("span", {
          style: {
            whiteSpace: "nowrap"
          },
          children: "Connect Wallet"
        })
      })), /*#__PURE__*/jsx(Portal, {
        children: /*#__PURE__*/jsx(Box, _objectSpread2(_objectSpread2({}, api.positionerProps), {}, {
          style: {
            zIndex: 9999,
            fontFamily: fontFamily
          },
          children: /*#__PURE__*/jsx(Menu, _objectSpread2(_objectSpread2({}, api.contentProps), {}, {
            children: !api.isOpen ? null : mountedAddress ? /*#__PURE__*/jsxs(Fragment, {
              children: [/*#__PURE__*/jsx(MenuItem, _objectSpread2(_objectSpread2({}, api.getItemProps({
                id: "copy",
                closeOnSelect: false
              })), {}, {
                leftElement: hasCopied ? /*#__PURE__*/jsx(FiCheck, {
                  width: "1em",
                  height: "1em",
                  color: "#57ab5a"
                }) : /*#__PURE__*/jsx(FiCopy, {
                  width: "1em",
                  height: "1em"
                }),
                onClick: function onClick() {
                  onCopy();
                },
                children: "Copy address"
              })), /*#__PURE__*/jsx(MenuItem, _objectSpread2(_objectSpread2({}, api.getItemProps({
                id: "switch-network",
                closeOnSelect: false,
                disabled: !switchNetwork
              })), {}, {
                isSelectable: false,
                leftElement: network.loading ? /*#__PURE__*/jsx(Spinner, {}) : network.error ? /*#__PURE__*/jsx(FiWifi, {
                  color: "#e5534b",
                  width: "1em",
                  height: "1em"
                }) : /*#__PURE__*/jsx(FiWifi, {
                  width: "1em",
                  height: "1em"
                }),
                children: /*#__PURE__*/jsx(SupportedNetworkSelect, {
                  value: chainId,
                  disabled: !switchNetwork,
                  onChange: /*#__PURE__*/function () {
                    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(e) {
                      var number;
                      return _regeneratorRuntime().wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              if (!(!switchingNetwork && switchNetwork)) {
                                _context.next = 14;
                                break;
                              }

                              switchingNetwork = true;
                              number = parseInt(e.target.value);
                              _context.prev = 3;
                              _context.next = 6;
                              return switchNetwork(number);

                            case 6:
                              _context.next = 11;
                              break;

                            case 8:
                              _context.prev = 8;
                              _context.t0 = _context["catch"](3);
                              console.error("failed to switch network", _context.t0);

                            case 11:
                              _context.prev = 11;
                              switchingNetwork = false;
                              return _context.finish(11);

                            case 14:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee, null, [[3, 8, 11, 14]]);
                    }));

                    return function (_x) {
                      return _ref2.apply(this, arguments);
                    };
                  }()
                })
              })), /*#__PURE__*/jsx(MenuItem, _objectSpread2(_objectSpread2({}, api.getItemProps({
                id: "disconnect"
              })), {}, {
                leftElement: /*#__PURE__*/jsx(FiXCircle, {
                  width: "1em",
                  height: "1em"
                }),
                onClick: function onClick() {
                  disconnect();
                  api.close();
                },
                children: "Disconnect"
              }))]
            }) : /*#__PURE__*/jsxs(Fragment, {
              children: [supportedConnectors.findIndex(function (c) {
                return c.name === "MetaMask";
              }) > -1 && /*#__PURE__*/jsx(MenuItem, _objectSpread2(_objectSpread2({}, api.getItemProps({
                id: "metamask"
              })), {}, {
                onClick: /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
                  return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          if (connecting) {
                            _context2.next = 6;
                            break;
                          }

                          connecting = true;
                          _context2.next = 4;
                          return connectWithMetamask();

                        case 4:
                          connecting = false;
                          api.close();

                        case 6:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                })),
                leftElement: /*#__PURE__*/jsx(Icon, {
                  boxSize: "1.5em",
                  name: "metamask"
                }),
                children: "MetaMask"
              })), supportedConnectors.filter(function (c) {
                return c.name !== "MetaMask";
              }).map(function (c) {
                return /*#__PURE__*/jsx(MenuItem, _objectSpread2(_objectSpread2({}, api.getItemProps({
                  id: c.id
                })), {}, {
                  onClick: /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            if (connecting) {
                              _context3.next = 6;
                              break;
                            }

                            connecting = true;
                            _context3.next = 4;
                            return connect(c);

                          case 4:
                            connecting = false;
                            api.close();

                          case 6:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  })),
                  leftElement: getIconForConnector(c),
                  children: c.name
                }), c.id);
              })]
            })
          }))
        }))
      })]
    })
  }));
};

var _excluded = ["contractAddress", "functionName", "params", "overrides", "onSuccess", "onError", "onSubmit", "isDisabled", "children"];

/**
 * A component that allows the user to call an on-chain function on a contract.
 *
 * The button has to be wrapped in a `ThirdwebProvider` in order to function.
 *
 * @example
 * ```javascript
 * import { Web3Button } from '@thirdweb-dev/react';
 *
 * const App = () => {
 *  return (
 *   <div>
 *     <Web3Button contractAddress="0x..." functionName="mint" />
 *   </div>
 * )
 * }
 * ```
 *
 *
 * @beta
 */
var Web3Button = function Web3Button(_ref) {
  var contractAddress = _ref.contractAddress,
      functionName = _ref.functionName,
      params = _ref.params,
      overrides = _ref.overrides,
      onSuccess = _ref.onSuccess,
      onError = _ref.onError;
      _ref.onSubmit;
      var isDisabled = _ref.isDisabled,
      children = _ref.children,
      themeProps = _objectWithoutProperties(_ref, _excluded);

  var address = useAddress();
  var walletChainId = useChainId();
  var sdkChainId = useActiveChainId();

  var _useNetwork = useNetwork(),
      _useNetwork2 = _slicedToArray(_useNetwork, 2),
      switchNetwork = _useNetwork2[1];

  var switchToChainId = useMemo(function () {
    if (sdkChainId && walletChainId && sdkChainId !== walletChainId) {
      return sdkChainId;
    }

    return null;
  }, [sdkChainId, walletChainId]);
  var contractQuery = useContract(contractAddress);
  var mutation = useContractCall(contractQuery.contract, functionName);

  var handleClick = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var vars, withOverrides, _result;

      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!switchToChainId) {
                _context.next = 10;
                break;
              }

              if (!switchNetwork) {
                _context.next = 8;
                break;
              }

              _context.next = 4;
              return switchNetwork(switchToChainId);

            case 4:
              _context.next = 6;
              return new Promise(function (resolve) {
                return setTimeout(resolve, 500);
              });

            case 6:
              _context.next = 10;
              break;

            case 8:
              console.warn("need to switch chain but connected wallet does not support switching");
              return _context.abrupt("return");

            case 10:
              if (!(typeof params === "function")) {
                _context.next = 16;
                break;
              }

              _context.next = 13;
              return params();

            case 13:
              _context.t0 = _context.sent;
              _context.next = 17;
              break;

            case 16:
              _context.t0 = params;

            case 17:
              vars = _context.t0;
              withOverrides = vars && overrides ? [].concat(_toConsumableArray(vars), [overrides]) : overrides ? [overrides] : vars;
              _context.prev = 19;
              _context.next = 22;
              return mutation.mutateAsync(withOverrides);

            case 22:
              _result = _context.sent;

              if (onSuccess) {
                onSuccess(_result);
              }

              _context.next = 30;
              break;

            case 26:
              _context.prev = 26;
              _context.t1 = _context["catch"](19);
              console.error("Error calling contract", _context.t1);

              if (onError) {
                onError(_context.t1);
              }

            case 30:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[19, 26]]);
    }));

    return function handleClick() {
      return _ref2.apply(this, arguments);
    };
  }();

  if (!address) {
    return /*#__PURE__*/jsx(ConnectWallet, _objectSpread2({}, themeProps));
  }

  return /*#__PURE__*/jsx(ThemeProvider, _objectSpread2(_objectSpread2({}, themeProps), {}, {
    children: /*#__PURE__*/jsx(Button, {
      style: {
        height: "50px"
      },
      isLoading: mutation.isLoading || !contractQuery.contract,
      onClick: handleClick,
      isDisabled: isDisabled,
      children: children
    })
  }));
};

export { ConnectWallet, MediaRenderer, ThirdwebNftMedia, ThirdwebProvider, ThirdwebSDKProvider, Web3Button, useActiveChainId, useActiveClaimCondition, useActiveListings, useAddress, useAirdropNFT, useAllContractEvents, useAllRoleMembers, useAuctionWinner, useBalance, useBatchesToReveal, useBidBuffer, useBuiltinContract, useBurnNFT, useBurnToken, useBuyNow, useChainId, useClaimConditions, useClaimIneligibilityReasons, useClaimNFT, useClaimToken, useClaimedNFTSupply, useClaimedNFTs, useCoinbaseWallet, useConnect, useContract, useContractAbi, useContractCall, useContractCompilerMetadata, useContractData, useContractEvents, useContractFunctions, useContractMetadata, useContractType, useCreateAuctionListing, useCreateDirectListing, useDelayedRevealLazyMint, useDesiredChainId, useDisconnect, useEdition, useEditionDrop, useGnosis, useGrantRole, useIsAddressRole, useLazyMint, useListing, useListings, useLogin, useLogout, useMagic, useMakeBid, useMarketplace, useMetadata, useMetamask, useMintNFT, useMintNFTSupply, useMintToken, useMultiwrap, useNFT, useNFTBalance, useNFTCollection, useNFTDrop, useNFTs, useNetwork, useNetworkMismatch, useOwnedNFTs, usePack, usePlatformFees, usePrimarySaleRecipient, useReadonlySDK, useResetClaimConditions, useResolvedMediaType, useRevealLazyMint, useRevokeRole, useRoleMembers, useRoyaltySettings, useSDK, useSetAllRoleMembers, useSetClaimConditions, useSignatureDrop, useSigner, useSplit, useToken, useTokenBalance, useTokenDrop, useTokenSupply, useTotalCirculatingSupply, useTotalCount, useTransferBatchToken, useTransferNFT, useTransferToken, useUnclaimedNFTSupply, useUnclaimedNFTs, useUpdateMetadata, useUpdatePlatformFees, useUpdatePrimarySaleRecipient, useUpdateRoyaltySettings, useUser, useVote, useWalletConnect, useWalletLink, useWinningBid };
